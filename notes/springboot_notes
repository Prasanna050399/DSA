Spring boot tutorial : 
	What is RAD ? 
		RAD or rapid application development is an adaptive software development model based on prototyping and quick feedbackk with less focus on specific planning. In other words it prioritizes the development and building of prototypes rather than planning. 
		It will focus on the current requirement and will work on implementing it.
		
		steps in RAD : 
			1. define the requirements :
				It does not sit with the end user like in traditional software development models. It instead asks for a broader set of requirements which helps us to segment specific requirements at different points of the development cycle.
			2. prototype : 
				In this phase the prototype is created, but instead of following rigid set of requirements, developers create prototypes with different features and functions as fast as they can. These prototypes contains only key features and the clients decide what they like and what they dont. The final product is only created during the finalization stage where the client and the developer are in alignment with the final product.
			3. construction : 
				This is crucial stage and is usually long. Developers and engineers work to create a working system from a working model. Feedbacks and reviews are important in this phase and most of the bugs, issues and alterations are fixed in this stage.
			4. deployment :	
				This is the final stage where the product is deployed into a live production environment. This phase includes intensive testing, technical documentation, issue tracking, final customization, system simulation, debugging and running final updates and maintenance before going live.
		
		Features of RAD : 
			1. cost saving
			2. increased value generation
			3. reduced risk
			4. enhanced customer satisfaction
	
	
	what is spring boot?
		Spring boot is a spring module that provides the RAD(rapid application development) feature to the spring framework.
		Spring boot is build on top of spring framework.
		Easy and fast way to configure, setup and run simple and web based applications.
		
		Spring uses convention over configuration software design paradigm meaning it decreases the effort of the developer.
		Spring Boot Extension is Spring's convention-over-configuration solution intended to aid in creating production-grade Spring applications with minimal amounts of configuration
		
	NOTE : 
		SPRING BOOT = SPRING FRAMEWORK + EMBEDDED HTTP SERVERS - XML CONFIGURATION OR @CONFIGURATION
		
		
	Why to use spring boot framework ? 
		1. spring boot uses dependency injection approach
		2. contains powerful database transaction management capabilities
		3. simplifies integration with other frameworks like JPA/Hibernate ORM, struts, etc.
		4. reduces development cost and time.

	Spring sister projects :
		1. spring data : simplifies data access
		2. spring batch : 
			provides powerful batch processing
		3. spring security :
			provides robust security.
		4. spring social : 
			supports integration with social networking.
		5. spring integration :
			facilitates integration with other enterprise application using lightweight messaging and declarative adapters.
	
	Advantages of spring boot : 
		1. can create stand alone spring applications that we can run using java -jar command
		2. have embedded http servers therefore, no need to deploy war files which makes it easy to test.
		3. provides starter poms to simplify our configuration
		4. provides production ready features.
		5. no need for xml configuration
		6. provides cli tool for developing and testing the spring boot application
		7. offers number of plugins
		8. minimizes writing of boiler plate code
		9. increases productivity.
		
	Limitations :
		Spring boot can add dependencies which are not used in the project which unecessarily increase the size of the project.
		
	
	Goals of spring boot :
		reduce development time
		reduce testing time
		reduce integration time
		Spring boot achieves this by :
			1. providing opinionated development approach
			2. avoiding defining more annotation configuration
			3. avoiding writing lots of import statement
			6. avoiding xml configuration.
	
	features of spring boot : 
		1. web development :
			This is a well suited spring module for web application development. It has embedded servers like tomcat and jetty to run the application.
		2. springApplication :
			This is a class that provides a convenient way to bootstrap a spring application. It can be started from main method. We can call the application by calling the static run() method.
		3. application events and listeners
		4. admin features : 
			Spring boot provides facilities to enable admin-related feature for the application.
			It is used to access and manage the application remotely.
			We can enable this feature in spring boot using the spring.application.admin.enabled property.
			
		5. properties file :
			spring boot provides a rich set of application properties which we can set in properties file. So the properties file helps to organize application properties.
		6. externalized configuration : 
			spring boot allows to externalize configuration so that we can work with the same application in different environments. For example same code but the env will change from dev to stage or to local or to prod. The application uses YAML files to externalize conifguration.
		7. yaml support : 
			It is an alternative for properties file. YAML provides a convenient way of specifying hierarchical configuration. SpringApplication calls automatically supports YAML.
		8. type-safe configuration : 
			strong type-safe configuration is provided to govern and validate the conifguration of the application. ApplicationCOnfiguration is always a crucial task which should be typ
		9. logging :
			spring boot uses common loggin for all internal login
		10. security : 
			spring boot applications are spring bases web application. 
			So it is secured by default on http endpoints. A rich set of endpoints is available to develop secure spring boot application.
			
			
			
Spring vs spring boot vs spring mvc : 
	
	spring : it is a java ee framework used to develop applications.
	spring boot : it is a spring module used to develop rest apis
	
	spring : aims to simplify java ee development
	spring boot : aims to shorten the code length and provide the easiest way to develop web application.
	
	spring : primary feature is DI
	spring boot : primary feature is autoconfiguration. Automatically configures the classes based on requirements.
	
	spring : need to add dependencies manually
	spring-boot : provides starter, that internally takes care of jars based on spring boot requirement.
	
	spring : does not support in memory db
	spring-boot : supports in memory db like H2.
	
	spring : contains lot of boiler plate code
	spring-boot : reduces boiler plate code
	


spring boot architecture : 
	spring boot follows a layered architecture.
	Each layer communicates with the layer directly below and above it.
	There are four layers in spring boot they are :
		presentation layer :
			this layer handles the requests, translates the json parameter to object, authenticates the request and transfer the request to the business layer. In short it consists of views i.e, frontend part.
		business layer :
			this layer contains business logic. It contains the service classes and uses services provided by data access layer. It performs authorization and validation as well.
		persistence layer :
			this layer contains storage logic and translates business objects from and to database rows.
		database layer :
			in this layer, CRUD operations are provided.
			
	spring boot flow architecture : 
		Spring boot uses all the modules of spring, like springmvc, spring data, etc. The architecture of spring boot is same as the architecture of spring mvc.
		the spring architecture contains 6 main components :
			1. client :
				the client makes http reqeust to controller.
			2. controller : 
				The controller takes this request and maps the request and handles it.
			3. service layer :
				In performs business logic in this layer. It performs logic on the data that is mapped to JPA with model classes.
			4. model
			5. database
			6.repository class extending CRUD services.
		References : 
		https://www.geeksforgeeks.org/spring-boot-architecture/
		
		
	what is BOM : 
		BOM stands for bill of material. It is a special kind of POM that is used to control the versions of project dependencies. It provides a central place to define and update those versions.
		
	While creating a project on spring initializer, we have to define the project metadata that contains the group name which defines the package name and the artifact name which defines the application name.
	We also add dependencies in it, these are the artifacts that we can add to our project.


	how to create a spring boot project without spring initializer ?
		1. create a maven project.
		2. inside the pom file, under the <properties> tag, define the java version that we want to use 
		3. since we want to create a spring boot project, add the dependency in it.
			artifactid : spring-boot-starter-parent
		4. we can also add the spring boot web dependency.
			artifactid : spring-boot-starter-web
		5. create a new class
		6. inside the main method that new class call the static run method of the SpringApplication class and give the class name as the parameter to this run method.
			SpringApplication.run(className.class)
		7. We need to annotate the class with @SpringBootApplication annotation.
		
		These are the steps to manually create a spring boot application. Now we can run the application by running the class containing the SpringApplication.run method as a java application.
		If the application starts running without error we get to see the log stating the "started className in x seconds"
		
	
	@SpringBootApplication : 
		This annotation is used to mark a configuration class that declares one or more bean method and also triggers auto-configuration and component scanning.
		
		this single annotation enables the following 3 annotations : 
			1. @EnableAutoConfiguration : to enable spring boots auto configuration mechanism
			2. @ComponentScan : It scans the packages for beans
			3. @Configuration : It enables us to add extra beans in the context or import additional configuration classes.
			
spring boot annotations :
		spring boot annotations are used to provide supplemental information about a program.
		It does not change the action of the compiled program.
		It does not have direct effect on the operation of the code they annotate.
		
		core spring framework annotation : 
			
			@Required : 
				it applies to the bean setter method. It indicates that the annotated bean must be populated at configuration time with the required property, else it will throw an exception stating BeanInitializationException.
			
			@Autowired : 
				Spring provides annotation based auto-wiring by providing @Autowired annotation. 
				We can use this annotation on instance variable, setter method and constructor.
				When we use the @Autowired annotation, the spring container auto-wires the bean by matching data-type.
			
			@Configuration :
				This is a class level annotation that is used to define that the class is a source of bean definition for the spring container
			
			@ComponentScan :
				This annotation is used along with the @Configuration annotation to scan for the packages for beans.
				We can define the base package to scan for spring components using this annotation.
				
			@Bean :
				This is a method level annotation that is used to tell the spring container that the following method is returning a bean instance.
				It is an alternative of XML tag.
				
		Spring framework stereotype annotation : 
			@Component :
				This is a class-level annotation. 
				It is used to mark the class as a bean for the spring context to manage.
				The spring framework pick it up and configure it in the application context as a spring bean.
			@Service :
				It is also a class level annotation and is a specialization of the @Component annotation. This annotation is used to define that the class contains business logic.
			@Repository :
				It is also a class level annotation and is a specialization of @Component annotation. 
				This annotation defines that the class is a repository.
				The repository is a DAO (data access object) that access the database directly.
				The repository does all the operations related to the database.
			@Controller :
				This is also a class level annotation. 
				It is a specialization of the @Component annotation.
				It marks a class as a web request handler. It is often used to serve web pages.
				It is mostly used with @RequestMapping annotation.
				
		Spring boot annotations : 
			@EnableAutoConfiguration :
				It enables the autoconfiguration feature of the spring context. Meaning it will auto-configure the bean that is present it the classpath and configures it to run the method.
				From spring boot 1.2.0, it was added under the @SpringBootAnnotation.
			@SpringBootApplication :
				It is used to mark the configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning.
				It is a combination of multiple annotations, @Configuration, @ComponentScan, @EnableAutoConfiguration
		
		Spring MVC and REST annotation : 
			@RequestMapping :
				It is used to map the web requests.
				It has many optional elements like :
					consumes
					header
					method
					name
					params
					path
					produces
					value
				This is a class level as well as method level annotation therefore, we can use it with both method and class.
			
			@GetMapping : 
				maps http get request on specific handler method. 
				Used to create a web service endpoint that fetches 
				Used instead of @RequestMapping(method = RequestMethod.GET)
			
			@PostMapping :
				maps http post request on specific handler method. 
				Used to create a web service endpoint that creates 
				used instead of @RequestMapping(method = RequestMethod.POST)
			
			@PutMapping : 
				maps http put request on specific handler method.
				Used to create a web service endpoint that creates or updates.
				Used instead of @RequestMapping(method = RequestMethod.PUT)
			
			@DeleteMapping :
				maps http delete request on specific handler method.
				Used to create a web service endpoint that deletes.
				Used instead of @RequestMapping(method = RequestMethod.DELETE)
			
			@PatchMapping :
				maps http patch request on specific handler method.
				used instead of @RequestMapping(method = RequestMethod.PATCH)
				http patch method is used for making partial changes to an existing resource.
			
			@RequestBody :
				Used to bind the http request body with an object in a method parameter.
				it uses the messageConverters to convert the body of the request.
				This is a variable level annotation and that to for the parameter of the method. When the parameter of the method is annotated as @RequestBody, the http request body is mapped to it.
			
			@ResponseBody : 
				It binds the method return value to the response body. 
				This annotation tells spring framework to serialize and return an object as a JSON or XML format.
			
			@PathVariable : 
				This is a variable level parameter. It is used to extract the values from url.
				We can use this annotation multiple times in a method.
			
			@RequestParam : 
				This is a variable level annotation. It is used to extract query parameters from the url. It can be used to set the default values if the query parameters are not present in the url.
			
			@RequestHeader :
				Used to get the request headers. 
				this is a method level annotation.
				The optional elements of the annotation are name, required, value, defaultValue.
				For each header we should specify separate annotations. 
				We can use this annotation multiple times in a method.
			
			@RequestController : 
				This is a combination of @Controller and @ResponseBody annotation.
				This is a class level annotation
				It eliminates the need to put @ResponseBody annotation on each method.
			
			@RequestAttribute :
				binds method parameters to request attribute.
				provides convenient access to request attributes from a controller method.
				Using this annotation, we can access objects that are populated on server side.
				

Spring boot dependency management : 
	Spring boot manages dependencies and configuration automatically. 
	Spring boot allows overriding dependencies version if required.
	Advantages : 
		provides centralization of dependency information by specifying the spring boot version in one place.
		avoids mismatch of different versions
	
	Maven dependency management system : 
		We define the following parent dependency in the <parent> tag of the pom.xml file : 
			spring-boot-starter-parent
		The maven project inherits the following features from spring-boot-starter-parent : 
			java compiler version
			utf-8 source encoding
			This inherits the dependency section from the spring-boot-dependency-pom. It manages the version of common dependencies.
			dependencies, inherited from parent pom
			We can override an individual dependency by overriding a property. To do this, we need to inject that dependency again inside the <properties> tag to override the previous one.
		
		We can change the java version by using the <java.version> tag.
		We can also add maven plugin in our pom.xml file. It wraps the project into executable jar file.
		
		spring boot without using parent POM : 
			If we don't want to use spring-boot starter-parent dependency, but still want to take advantage of the dependency management, we can use <scope>
			eg : 
				<dependencyManagement>
					<dependencies>
						<dependency>
							<groupId>org.springframework.boot</groupId>  
							<artifactId>spring-boot-dependencies</artifactId>  
							<version>2.2.2.RELEASE</version>  
							<type>pom</type>  
							<scope>import</scope>  
						</dependency>
					</dependencies>
				</dependencyManagement>
		
			To override dependency, we need to add the dependency in the dependency section before the main dependency
			eg.
				<dependencyManagement>
					<dependencies>
						<dependency>
							override dependency
							<scope>import</scope>
						</dependency>
						<dependency>
							overridden dependency 
						</dependency>
					</dependencies>
				</dependencyManagement>
		
	
spring boot application properties :
	Spring boot provides a built in mechanism for application configuration using a file called application.properties.
	This file is under src/main/resources folder.
	we can configure various properties inside the application.properties.
	We can define our own properties in this file or we can set values for property of spring boot application.
	
	used to run an application in different environment.
	
	The application properties do 2 things,
		1. configure spring boot framework
		2. define our application custom configuration properties.
		
	Spring boot provides another way to configure the properties called yml file.
	The YAML file works because the Snake.YAML jar is present in the classpath.
	So we can use the yaml file instead of application.properties file. The only thing required is that the YAML file should be present in the classpath.
	
	

spring boot property categories :
	total 16  :
		1. core properties
		2. cache properites
		3. mail properties
		4. json properites
		5. data properties
		6.transaction properites
		7. data migration properties
		8. integration properites
		9. web properties
		10. template properties
		11. server properites
		12. security properites
		13. RSocket properites
		14. actuator properties
		15. devTools program
		16. testing properites
		
Spring boot starters : 
	Spring boot starters are the dependency descriptors.
	Spring boot provides a number of starters that allow us to add jars in classpath.
	Spring starters have a similar naming pattern :
		spring-boot-starter-*
	Spring boot starters are not used to include third party dependencies.
	Spring boot starter is reserved for official spring boot artifacts.
	Third party starters have the following pattern :
		projectName-spring-boot-starter

spring boot starter parent :
	Spring boot starter parent is a project starter, it gives default configuration for our application.
	All spring boot projects use spring boot starter parent as a parent in pom.xml file.
	All the dependencies use this internally.
	
	parent pom helps us manage the following things for multiple child projects and modules : 
		1. configuration : maintains consistency of java version and other related properties.
		2. dependency management : controls versions to avoid conflicts
		3. source encoding
		4. default java version
		5. resource filtering
		6. controls default plugin configuration.
		
	spring-boot-starter-parent have spring-boot-dependencies as its parent pom.
	
	the properties section defines the application default values.
	<java.version> : overrides java version.
	
	spring-boot-starter-parent specifies the default configuration for a host of plugins including maven-failsafe-plugin, maven-jar-plugin and maven-surefire-plugin
	
	Spring-boot-starter-parent dependency inherit from the spring-boot-dependencies, it shares all these characteristics as well. Hence SB manages the list of dependencies as a part of dependency management.
	If we dont want to use spring boot starter parent then we can use the dependencies individually along with the <scope> tag.
	
spring boot starter web : 
	two important features for spring boot starter web : 
		1. it is compatible for web development
		2. auto configuration
	
	spring-boot-starter-web transitively pull all the dependencies that are related to web development.
	It uses spring mvc, rest and tomcat as embedded server.
	it transitively depends on : 
		spring-boot-starter
		spring-boot-starter-tomcat
		spring-boot-starter-validation
		jackson-databind
		spring-web
		spring-webmvc
	
	spring-boot-starter-web auto-configures the following things that are required for web development :
		1. dispatcher servlet
		2. error page
		3. web jars for managing the static dependencies
		4. embedded servlet container
	
	spring boot embedded web server : 
		each spring boot application have embedded server. It is a part of deployable application. We dont need to install a server in the environment. The default embedded server is tomcat. It also supports :
			jetty -> spring-boot-starter-jetty
			undertow -> spring boot-starter-undertow
		
		Jetty server : 
			http server and servlet container that is capable of serving static and dynamic content. 
			Used when machine to machine communication is required.
		
		NOTE : WHILE USING JETTY, WE NEED TO EXCLUDE TOMCAT FROM STARTER-WEB TO AVOID CONFLICT BETWEEN SERVERS.
		
		Undertow server :
			written in java and managed and sponsored by JBoss. 
			advantage of undertow server : 
				1. support http/2
				2. http upgrade support
				3. websocket support
				4. provides support for servlet 4.0
				5. flexible
				6. embeddable
		NOTE : SIMILAR TO JETTY, WHILE USING UNDERTOW, WE NEED TO EXCLUDE TOMCAT FROM THE STARTER-WEB DEPENDENCY TO AVOID CONFLICT.
		
		starter-web vs starter-tomcat : 
			starter-web contains alld the dependencies required for web development which includes tomcat as well.
			starter-tomcat includes all the dependencies related to tomcat.
			starter-web includes : 
				spring-boot-starter
				jackson
				spring-core
				spring-mvc
				spring-boot-starter-tomcat
			starter-tomcat includes : 
				core
				el
				logging
				websocket
classpath : 
	class path is a path where the java virtual machine look for user defined classes, packages and resources in java program.
	
how to exclude a dependency in pom?
	we can use the <exclusions> and inside it <exclusion> tag inside the <dependency> tag to exclude a dependency.
	eg: 
		<dependency>
			<groupid></groupid>
			<artifactId></artifactId>
			<exclusions>
				<exclusion>
					<groupid></groupid>
					<artifactId></artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		
spring data jpa :
	spring data is a high-level spring source project which aims to unify and ease access to the different kinds of persistence stores, both relational and nosql data stores.
	main aim should be business logic and not boiler plate code and technical complexity.
	
	spring data jpa adds a layer on top of JPA. It means that spring data jpa uses all features defined by JPA specification, especially the entity, association mapping and jpa's query capabilities.
	
	spring data jpa adds its own features such as the no-code implementation of the repository pattern and the creation of database queries from the method name.
	
	spring data jpa handles most of the complexity of JDBC-based database access and ORM.
	reduces boilerplate code required by JPA.
	faster and easier implementation of persistence layer.
	aims to improve the implementation of data access layers by reducing the efforts.
	
	features : 
		1. no code repository :
			enables us to implement our business layer at higher abstraction level
		2. reduced boilerplate code 
		3. generated queries : If the query is not too complex, we need to define a method on our repository interface with the name that starts with findBy. Spring parses the method name and creates a query for it.
		4. can integrate custom repository code
		5. is a powerful repo and custom object-mapping abstraction
		6. supports transparent auditing
		7. implements domain base class that provides basic properites
		8. supports several modules such as data jpa, data mongodb, rest, cassandra
		
		
	spring data repository :
		spring data jpa provides 3 repository :
			1. crudRepository :
				it offers standard create, read, update and delete. It has methods like findOne(), findAll(), save(), delete(), etc.
			2. pagingAndSortingRepository :
				extends crudRepository and adds findAll methods. 
				allows to sort and retrieve paginated data
			3. JpaRepository :
				JPA specific repository.
				defined in spring data jpa.
				extends both the crudRepository and pagingAndSortingRepository.
				adds methods like flush() to trigger a flush on the persistence context.
				
				
	spring boot starter data jpa : 
		to connect spring application with relational database, spring boot provides spring-boot-starter-data-jpa.
		spring-boot-starter-data-jpa internally uses spring-boot-jpa dependency from SB version 1.5.3
		
		In jpa, we store the data from objects into table and vice-versa.
		JPA allows us to map application classes to table in the database.
			Entity manager : after the mapping is defined, it handles all the interactions with the database.
			JPQL(java persistence query language) : provides a way to write queries to execute searches against entities. Different than sql queries, JPQL queries already understand the mapping that is defined between entities. can add additional conditions.
			criterial API : provides java based apis to execute searches against the db.
			
			
	hibernate vs jpa :
		hibernate is an implementation of jpa. 
		Hibernate is most popular ORM framework.
		JPA is an api that defines the specification.
		Hibernate understands the mapping that we add between objects and tables. 
		Ensures data is stored and retrieved from the database based on the mapping.
		Provides additional features on top of JPA.
		

spring boot starter actuator: 
	in sb, actuator is the subproject of spring boot framework.
	It includes a number of aditional features that help us to monitor and manage the SB applications.
	We can use http and jmx endpoints to manage and monitor the SB application.
	For production ready features in an application, we should use spring boot actuator.
	
	features : 
		3 main features :
			endpoints :
				actuator endpoints allows us to monitor and interact with the application.
				spring boot provides a number of built-in endpoints.
				can create our own endpoint
				can enable and disable each endpoint individually.
			metrics : 
				actuator provides dimensional metrics by integrating with the micrometer.
				it is an instrumentation library powering the delivery of application metrics from spring.
				provides vendor neutral interfaces for timers, gauges, counters, distribution summaries and long task timers with a dimensional data model.
			audit : 
				provides a flexible audit framework that publishes events to an auditEventRepository.
				Automatically publishes the authentication events if spring-security is in execution.
	
	To enable actuators we need to add spring-boot-starter-actuator dependency in pom.xml file.
	
	spring boot enables security for all actuator endpoints.
	We need to override this configuration by management.security.roles property.
	
spring boot starter test :
	primary dependency for test
	contains majority of elements required for tests
	
	NOTE : IF WE ARE ADDING TEST DEPENDENCY MANUALLY, ADD IT TO THE BOTTOM OF THE POM FILE.
	
	Also while adding the test dependencies we can add the scope as test.
		<scope>test</scope>
	This means that when the application is bundled and packaged for deployment, dependencies with scope as test will be ignored and are available only when running in development and maven test modes.
	
	
	The test class contains two annotations : 
		1. @SpringBootTest :
			It is applied on a test class.
			It uses springBootContextLoader as the default contextLoader if no specific @ContextConfiguration(loader=..) is defined
			Automatically searches for a @SpringBootConfiguration when nested @Configuration is not used, and no explicit classes are specified.
			Provides support for different webEnvironment modes.
			It registers a testRestTemplate or webTestClient bean for use in web tests that are using the webserver.
			Allows application arguments to be defined using the args attribute.
		2. @Test : 
			used to denote that the following method is a test method.

spring boot devTools : 
	devTools stand for developer tool. 
	aims to try and improve the development time while working with the spring boot application.
	spring boot devTools pick up the changes and restart the application automatically.
	
	to implement the devTools, we just need to add the dependency in the pom file
	
	<dependency>  
		<groupId>org.springframework.boot</groupId>  
		<artifactId>spring-boot-devtools</artifactId>  
		<scope>runtime<scope >  
	</dependency>
	
	features of spring boot devTools : 
		property defaults : 
			when we use devTools, we dont need to set the properties. For example, we dont need to set the property for disabling caching for thymeleaf, freemarker, groovy templates etc.
			NOTE : IF WE DONT WANT TO APPLY PROPERTY DEFAULTS ON AN APPLICATION, WE CAN SET CONFIGPROP:SPRING.DEVTOOLS.ADD-PROPERTIES[] TO FALSE IN THE APPLICATION.PROPERTIES FILE.
		automatic restart : 
			auto restart means reloading java classes and configure it at server side. 
			When there are changes in the source code, it restarts the server and deploy the latest code.
			mostly used for microservice based application.
			Two types of classLoaders :
				1. base classLoader for loading classes that do not change(third party jars)
				2. restart classLoader for loading classes that are actively developed.
			when application restarts, restart classloader is emptied and the populated again, but the base classLoader remains as is.
			
			NOTE : 
				TO DISABLE THE AUTO-RESTART OF A SERVER WE CAN USE THE PROPERTY :
					SPRING.DEVTOOLS.RESTART.ENABLED = FALSE
			
			devtools monitor the classpath resources.
			the restart only happens when the classpath is updated
			devtools require a separate classpath to work properly.
			devtools depend on application context's shutdown hook to close it during the restart.
		liveReload : 
			DevTools include an embedded server called liveReload.
			It allows the application to automatically trigger browser refresh whenever we make changes in the resources.
			Also known as auto-refresh.
			NOTE : 
				WE CAN DISABLE THE LIVERELOAD BY SETTING THE PROPERTY :
					SPRING.DEVTOOLS.LIVERELOAD.ENABLED = FALSE
			
			only one livereload server can be ran at a time
			we need to ensure that no other server is running
			only first reload server is supported at a time
			
		Remote debug tunneling : 
			SB can tunnel JDWP over HTTP directly to the application.
		Remote update and restart : 
			devtools monitor local classpath for file changes and pushes them to a remote server, which is then restarted.
			
	Trigger-file :
		automatic restart can sometimes slow down development time due to frequent restarts. To solve this problem, SB monitors a trigger file and detects modifications to that file. When this file is changed, it restarts the server.
		To implement trigger file update, we need to set the following property : 
			spring.devtools.restart.trigger-file : filePath/fileName
			
	NOTE : 
		DEVTOOLS ARE AUTOMATICALLY EXCLUDED WHEN IN PRODUCTION USING THE JAR PACKAGING. SO WE DONT NEED TO MANUALLY REMOVE THEM. 
		WE CAN ALSO EXCLUDE THEM USING THE EXCLUDEDEVTOOLS BUILD PROPERTY.
		
Spring boot multi-module project : 
	what is a multi-module project ? 
		A SB project that contains nested maven project is called the multi-module project.
		in multi-module project, the parent project works as a container for base maven configurations.
		a multi-module project is built from a parent pom that manages a group of submodule. Or a multi-module project is defined by a parent pom referencing one or more submodules
		
	The parent maven project must contain the packaging type pom that makes the project as aggregator.
	For this consider the example of pipeline management, the parent pom has the packaging type as pom : 
		<packaging>pom</packaging>
	
	
	The parent pom file contains all the modules, common dependencies and properties that are inherited by the child projects. The parent pom is located in the project's root directory.
	Child modules are actual spring boot projects that inherit the maven properties from the parent project.
	
	When we run the multi-module project, all the modules are deployed together in an embedded tomcat server.
	individual module can also be deployed.
	
	Parent pom : 
		it defines the group id, artifact id, version and packaging.
		packaging is defined as pom which refers to other maven projects.
	
	need for multi-module project ? 
		makes it easy to maintain 
		we can easily edit and remove the modules as and when needed without affecting the other modules
		useful when we need to deploy the modules individually
		dependencies are easily maintained because the they are inherited from the parent pom.
		
	child modules -> EAR, WAR, JAR : 
		child module can be any project that can have any packaging.
		we are free to create any type of dependency between modules and bundle them together
		For example, we are creating an EAR (Enterprise ARchive), WAR (Web ARchive), and JAR (Java ARchive) file.
	
	maven child projects/modules : 
		the child projects are independent maven projects that share properties from the parent project.
		they can be built with a single command because they are inside one big parent container
		easy to define relationship between projects.
	
	multi-module project directory structure : 
		the structure contains : 
			parent pom
			src folder for parent project
			maven dependencies
			target folder
			childModuleFolder1
			childModuleFolder2
			
		The parent pom is similar to any other spring boot project.
		Only change is that it contains the packaging type as pom instead of jar.
		And one more thing is that the it contains a modules section. 
		This section is automatically configured by spring boot when we create a maven module in the project.
		the modules section is as follows : 
			<modules>
				<module>module1</module>
				<module>module2</module>
			</modules>
			
		child pom file :
			this file does not contain common dependencies like the starter-web, web-mvc etc
			it inherits it from the parent pom


spring boot packaging : 
	In J2EE the application modules are packed in following compressed file formats :
		EAR : 
			enterprsie archive
			ear file represents enterprise application
			the above two files are archived as jar files with .ear extension.
			deployed into application server
			can contain multiple EJB(JAR) and WEB(WAR) modules.
			it is a special jar that contains an application.xml filein the meta-inf folder
		WAR : 
			Web archive.
			represents web applications
			module contains servlet classes, JSP files, html files, js, etc. which are packaged as a JAR file with .war extension.
			contains special directory called WEB-INF
			
			WAR module loads into a web container of java application server. The application server has two containers : 	
				web container :
					it hosts the web application based on servlet API and JSP.
					modules should be packaged as war for this
					it is a war file special jar file that contains a web.xmlv file in the web-inf folder
				ejb container :
					it hosts enterprise java beans based on EJB api.
					requires EJB modules to be packaged as a JAR file.
					contains an ejb-jar.xml file in the meta-inf folder
			
			advantage : 
				easily deployed on client machine in a web server environment
			needs web server or web container to execute war file
			example of web container:
				tomcat
				weblogic
				websphere
		JAR :
			java archive
			An EJB module that contains bean files, a manifest and EJB deployment descriptor are packaged as JAR files with the extension .jar. 
			Used to distribute java classes and various metadata
			In other words a file that encapsulates one or more java classes, a manifest and descriptor is called jar file.
			lowest level of archive
			used in J2EE for packaging EJB and client-side java applications
			makes it easy to deploy

spring boot auto-configuration :
	SB automatically configures the spring application based on the jar dependencies that we have added
	For example, if the H2 database Jar is present in the classpath and we have not configured any beans related to the database manually, the Spring Boot's auto-configuration feature automatically configures it in the project.
	
	to enable autoconfiguration we need to annotated the main class with @EnableAutoConfiguration annotation. But this annotation is wrapped inside @SpringBootApplication annotation therefore we dont need to specify it explicitly.
	
	When we add spring-boot-starter-web, SB auto-configuration looks for the spring mvc on the classpath. It then auto-configures dispatcherServlet, a default error page, and web jars.
	similarly for spring-boot-starter-data-jpa, it auto-configures a datasource and an entity manager.
	
	NOTE : THE AUTO-CONFIGURATION LOGIC IS INSIDE THE SPRING-BOOT-AUTOCONFIGURE.JAR
	
	We need auto-configuration because in its abscence, we need to configure each bean individually.
	
	Disabling auto-configuration : 
		Disabling using the annotation : 
			we can use the exclude property for excluding the classes.
			This property can be used with both the @SpringBootApplication annotation and @EnableAutoConfiguration annotation.
			@SpringBootApplication(exclude = {
				className.class,
				className.class
			})
		Disabling using the property file : 
			we can disable the auto-configure for a class using the following property in the property file : 
				spring.autoconfigure.exclude = \className,\className
				
	Debugging auto-configuration : 
		1. turning on debug logging :
			adding the following property in the application properties :
				logging.level.org.springframework: DEBUG
			
			Now the logs contain a section called as auto configuration report.
			The report includes all the classes that are auto-configured.
			It have 2 sections : 
				1. positive matches :
					classes which were matched
				2. negative matches
					classes which were not matched
		2. using spring boot actuator
			we need to add the spring-boot-starter-actuator dependency.
			we can then use the 
				/actuator/beans 
			endpoint to see the beans info that is auto-configured and that is not.

project deployment using tomcat : 
	how to deploy SB application using tomcat server ?
		steps :
			1. setting up spring boot application : set up the application and create a controller which will return a simple string
			2. create a spring boot war : 
				The spring framework's servlet 3.0 support is used which allows us to configure application when the servlet container launches it.
				Steps to create a WAR : 
					1. extend the springBootServletInitializer class in the main class.
					2. override the configure method of springBootServletInitializer in the main class. We tell spring to build the sources from the main class : 
						@Override
						protected SpringApplicationBuilder configure(SpringApplicationBuilder application)   
						{  
							return application.sources(SpringBootWarDeploymentExampleApplication.class);  
						} 
					3. configure the packaging to WAR
					4. build the package : 
						mvn package
						This will generate the war file in the target folder.
			3. deploying that war to tomcat : 
				1. add the dependency for tomcat with scope as provided
				2. we can change the name of the war file by using the <finalName> tag.
				3. To deploy the war file on tomcat : 
					1. install apache tomcat server
					2. copy the WAR file from the target folder and paste it inside the webapps folder of the tomcat folder.
					eg : 
						C:\Program Files\Apache Software Foundation\Tomcat 8.5\webapps  
					3. Go in the tomcat installed directory, inside the bin folder and open cmd. Then execute the startup command.
					eg. : 
						C:\Program Files\Apache Software Foundation\Tomcat 8.5\bin> startup
					4. The startup command starts the tomcat server and deploys the war file
					The server is now running 
			We can now access the server using the localhost:8080 : eg. http://localhost:8080/web-service/urlpath

spring boot AOP : 
	Java application has the following layers :
		1. web layer : exposes the services using the REST or web application.
		2. business layer : implements the business logic
		3. data layer : implements the persistence logic

	even though the functionality of all the layers is different, but there are some aspects that apply to all the layers like logging, security, validation, caching, etc. These common aspects are called cross-cutting concerns.
	
	To avoid duplicate implementation of the same code for each layer, we have aspect-oriented programming. AOP provides a solution to implement cross-cutting concerns.
	It does so using the following steps : 
		1. implement the cross-cutting concern as an aspect
		2. defining pointcuts to indicate where the aspect has to be applied.
	This ensures that the code is one cohesive component.


	AOP : 
		programming pattern
		increases modularity by following the separation of cross-cutting concerns
		cross-cutting concerns are different than bussiness logic
		adding additional behavior to the code without modifying the code itself.
		
		Springs aop framework helps implementing these cross-cutting concerns.
	
		aspects are the classes where the cross-cutting concerns are implemented.
		Using aop all the common functionality is in one place.
		we can define how and where to apply the additional functionality.
	
	benefits of aspects : 
		1. all the logic for a concern is in one place. Instead of in different classes
		2. business layer consist of only the business logic. Secondary concern is moved to the aspect.
		2. business layer consist of only the business logic. Secondary concern is moved to the aspect.
	
	apects have responsibility that is to be implemented, called advice.
	The aspect's functionality can be implemented into program at any and at one or more join points.
	
	benefits of AOP :
		implemented in pure java
		no requirement for special compilation processing
		supports only method execution join points
		run time weaving is available
		two types of AOP proxy available JDK dynamic proxy and CGLIB proxy.
	
	AOP terminology :
		aspect : 
			module that encapsulates advice and pointcuts and provides cross-cutting.
			can have multiple number of aspects.
			Aspect is a normal class with @Aspect annotation.
		pointcut : 
			expression that selects one or more join points where  advice is executed.
			can define pointcuts using expression or patterns
			in spring framework, AspectJ pointcut expression language is used.
		join point : 
			join point is a point in application where we want to apply AOP aspect.
			or it is a specific execution instance of an advice.
			In AOP join point can be method execution, exception handling, changing object variable value, etc.
		advice  :
			advice is an action that we take at join point.
			action is a piece of code that invokes during program execution
			five types of advices in spring AOP :
				before : 
					executed before the join point
				after : 
					executed after the join point
				after-returning :
					executed after method execution was successful
					We can access the return value in the advice. We need to add one more parameter to the method which corresponds to the name of the variable returned by the join point method.
					@AfterReturning(value="execution()", returning="name of the returning attribute" )
				after-throwing : 
					executed if the method execution threw exception
					@AfterThrowing(PointCut="execution()", throwing = "name of the exception to be returned")
					The name (ex) that we define in the throwing attribute must correspond to the name of a parameter in the advice method. Otherwise, advice will not run.
				around advice : 
					executed before and after method execution
					this is most powerful advice.
					We use the ProceedingJoinPoint as a parameter to the advice method.
					The parameter.proceed() method is used to continue the execution of the join point method.
					So the idea is like : 
						code we want to execute before join point
						proceedingJoinPoint.proceed();
						code we want to execute after join point.
		target object : 
			object on which the advices are applied.
			target object are always proxied, meaning a subclass is created at run time in which the target method is overridden and advices are included based on their configuration.
		Weaving : 
			process of linking aspects with other application types.
			we can perform weaving at run time, load time and compile time.
	
	difference between AOP and OOP :
		https://www.javatpoint.com/spring-boot-aop
	differnece between spring AOP and AspectJ : 
		https://www.javatpoint.com/spring-boot-aop
		
	
	To implement AOP in application, we are required to add the Spring AOP dependency in pom.xml :
		spring-boot-starter-aop
	This dependency provides spring aop and aspectJ
	Spring AOP provides basic AOP capabilities. 
	AspectJ provides complete AOP framework
	
	We need to annotate the main class with the @EnableAspectJAutoProxy(proxyTargetClass=true) annotation.
	
	@EnableAspectJAutoProxy : 
		This annotation enables support for handling components marked with AspectJ's @Aspect annotation.

Spring boot jpa : 
	SB JPA is a java specification for managing relational data in java applications.
	JPA follows ORM(object relation mapping)
	It is a set of interfaces.
	uses platform independent object oriented query language JPQL(java persistent query language)
	The main advantage of jpa over jdbc is that, in JPA, the data is represented in terms of objects and classes while in JDBC it is represented by tables and records. 
	JPA uses POJO to represent persistent data that simplifies database programming.
	
	advantages of JPA : 
		1. avoids writing DDL in database specific dialect of sql. Instead allows mapping in XML or using java annotations.
		2. avoids writing DML in the database-specific dialect of sql
		3. allows to save and load objects and graphs without using DML languages
		4. while writing queries in JPQL, allows to express queries in terms of java entities rather than the sql table and columns.
		
	features of jpa : 
		1. it is a powerful repository and custom object mapping abstraction
		2. supports cross-store persistence. Meaning an entity can be partially stored in MySQL and Neo4j
		3. dynamically generates queries from queries methods name
		4. domain base classes provide basic properites
		5. supports transparent auditing
		6. possibility to integrate custom repository code
		7. easy to integrate with spring framework with custom namespace
		
	architecture of jpa : 
		jpa is a source to store business entities as relational entities.
		shows how to manage POJO as an entity and how to manage entity with relation
		
		class level architecture of jpa : 
			the core classes and interfaces of jpa is defined in the javax persistence package.
			jpa architecture contains following units : 
				
				Persistence : 
					Class that contains static methods to obtain instance of entityManagerFactory instance
				EntityManagerFactory :
					factory class for EntityManager.
					creates and manages mulitple instances of entityManager class.
				EntityManager :
					Its an interface
					controls the persistence operations on objects.
					works for the query instance
				Entity : 
					The entities are the persistence objects stored as a record in the database
				Persistence Unit :
					defines set of all entity classes
					In an application, EntityManager instance manages it.
					Set of entity classes represents the data contained within a single data store.
				EntityTransaction :
					for each entityManager, operations are maintained by entityTransaction class.
				Query : 
					This is an interface that is implemented by each JPA vendor to obtain relation objects that meet the criteria.
			
			all the units except entity, are part of javax.persistence
			
		JPA class relationships : 
			entityManager and entityTransaction -> one to one
			entityManagerFactory and entityManager -> one to many
			entityManager and query -> one to many (can execute any number of queries by using an instance of entityManager)
			entityManager and entity -> one to many (one entityManager instance can manage multiple entities)
		JPA implementation :
			jpa is an open source API.
			Hibernate, EclipseLink, DataNucleus are implementations of JPA.
			It is also known as ORM(Object relation mapping) tool.
		
		ORM (Object relation mapping) : 
			Mapping of java objects to database tables, and vice-versa is called as object relational mapping.
			The ORM mapping works as a bridge between a relational database and java application.
			The ORM is an adaptor layer between the language of object graphs to the language of SQL table.
			ORM layer is between the application and the database.
			It converts the java classes and objects so that they can be stored and managed in relational database. 
			By default the name that persists becomes the table name and the fields become the columns.
			Each row in the table becomes an object.
	JPA vs hibernate : 
		https://www.javatpoint.com/spring-boot-jpa
	
	To connect SB application with relational database efficiently, we have spring-boot-starter-data-jpa dependency.
	spring-boot-starter-data-jpa internally uses spring-boot-jpa dependency
	
	Apache derby : 
		open source, embedded relational database implemented entirely in java.
		available under apache 2.0 license.
		advantages of apache derby : 
			1. easy to install, deploy and use
			2. based on java, jdbc and sql standards
			3. provides embedded JDBC driver that allows us to embed derby in any java-based application
			4. supports client/server mode with derby network client JDBC driver and derby network server.
		We can integrate derby database just by adding derby dependency in pom.xml file.
		Rest of the configuration is similar to our multi omics project.
		create a model
		create an interface and extend CrudRepository
		use this interface to access the db in service
	SB can auto-configure an embedded database such as H2, HSQL and DerbyDatabases.
	We do not need to provide any connection URLs. All we need to do is include a build dependency on the embedded database that we want to use.
	
Spring boot jdbc : 
	SB JDBC provides starter and libraries for connecting an application with JDBC.
	In SB JDBC, the database related beans such as dataSource, jdbcTemplate and NamedParameterJdbcTemplate auto-configures and created during startup.
	We can auto-wire these classes if we want to use it.
	
	JDBC connection pooling : 
		JDBC connection pooling is a mechanism that manages multiple database connection requests.
		In other words, it facilitates connection reuse, a memory cache of database connections, called a connection pool.
		A connection pooling module maintains it as a layer on top of any standard JDBC driver product.
		it increases the speed of data access and reduces the number of database connections for an application.
		Connection pool performs the following tasks :
			manage available connection
			allocation new connection
			close connection
		
		HikariCP : 
			The default connection pool in spring boot 2 is HikariCP.
			It provides enterprise-ready features and better performance.
			it is a JDBC DataSource implementation that provides a connection pooling mechanism.
		
		if hikariCP is present in the classpath, SB automatically configures it.
		if hikariCP is not present, then spring boot looks for the tomcat JDBC connection pool. 
		if both the above options are not available, SB chooses apache commons DBCP2 as the JDBC connection pool
	
	we need to add the database specific driver.
	after the driver is added in the dependencies, we need to define the datasource properties in application.properties file.
	we need to set following properties : 
		1. spring.datasource.url=dataSourceUrl
		2. spring.datasource.username=username
		3. spring.datasource.password=password
	
	spring boot jdbc vc spring jdbc : 
		https://www.javatpoint.com/spring-boot-jdbc
	
	JDBC vs hibernate : 
		https://www.javatpoint.com/spring-boot-jdbc

	spring boot h2 database : 
		what is in-memory database ?
			uses system memory in place of disk space for storage of data.
			We use the in memory database when we dont want to persist the data.
			The in-memory database is volatile and it is lost when we restart the application.
			widely used databases are H2, HSQLDB(HyperSQL database) and apache derby. These databases are configured automatically.
		
		what is h2 database? 
			it is an embedded, open-source and in-memory database.
			relational database management system written in java.
			generally used for unit testing
			stores data in memory, not persist data on disk.
			
		advantages of h2 : 
			zero configuration
			light weight and fast
			easy to use
			provides simple configuration to switch between a real database and in-memory database
			supports standard sql and jdbc api
			provides web console to maintain in the database
		
		configure h2 database : 
			add h2 dependency in the pom file
			we need to configure data source url, driver class name, username and password of h2 database
		
		persist the data in h2 database : 
			if we want to persist the data in h2 database,  we should store the data in a file.
			To achieve this, we need to change the datasource url property.
			eg : 
				spring.datasource.url = jdbc:h2:c:/folder/fileName
				
		creating schema and populating data : 
			defining schema by creating sql file in the resource folder :
				schema.sql
			populating data in the table by creating a sql file in the resource folder : 
				data.sql
			spring boot automatically picks up the data.sql file and run it against the h2 database while starting the application.
		
		H2 console : 
			by default the h2 database console is disabled, we need to enable it before accessing the console.
			The following property is used to enable h2 console : 
				spring.h2.console.enabled = true
			We can access the console using browser and visiting  :
				localhost:8080/h2-console
				
		CrudRepository vs JpaRepository : 
			https://www.javatpoint.com/spring-boot-crud-operations
		
spring boot thymeleaf : 
	It is an open source java library, licensed under apache 2.0. It is a HTML5/XHTML/XML template engine.
	it is server-side java template engine for both web(servlet based) and non web(offline) environments
	provides full integration with spring framework
	
	The goal of thymeleaf is to provide a stylish and well-formed way of creating templates.
	It is based on xml tags and attributes.
	These XML tags define the execution of predefined logic on the dom instead of explicitly writing that logic as code inside the template.
	It is substitute for JSP.
	
	why we use thymeleaf ? 
		jsp is more or less similar to html but it is not completely compatible with html like thymeleaf.
		We can open and display thymeleaf template file normally in browser while the jsp file does not.
		
	what kind of templates can the thymeleaf process ?
		thymeleaf can process six types of templates AKA tempalte mode. They are as follows : 
			XML
			valid XML
			XHTML
			Valid XHTML
			HTML5
			legacy HTML5

spring boot caching : 
	spring framework provides caching in spring application, transparently.
	In spring, the cache abstraction is a mechanism that allows consistent use of various caching methods with minimal impact on the code.
	The cache abstraction mechanism applies to java methods.
	Main objective of using cache abstraction is to reduce the number of executions based on the information present in the cache.
	
	For each method calls, the abstraction applies a cache behavior to the method. It checks whether the method has already been executed for the given argument or not.
	If yes, the cached result is returned without executing the actual method.
	If no, the method executes, result is cached and returned to the user.
	Note: This approach works only for the methods that are guaranteed to return the same result for a given input. It does not matter how many times the method executes.
	
	The developers take care of two things while working with cache abstractions : 
		1. cache declaration : 
			It identifies the method that need to be cached
		2. cache configuration :
			The backing cache where the data is stored and read from.
	Caching
		Caching is a part of temporary memory (RAM). It lies between the application and persistence database. It stores the recently used data that reduces the number of database hits as much as possible. In other words, caching is to store data for future reference.
	
	why should we use the cache?
		The primary reason for using cache is to make data access faster and less expensive. When the highly requested resource is requested multiple times, it is often beneficial for the developer to cache resources so that it can give responses quickly.
	
	what data should be cached ?
		The data that do not change frequently
		The frequently used read query in which results does not change in each call, at least for a period.
	
	types of caching : 
		1. in-memory caching : 
			increases the performance of the application.
			It is the area that is frequently used
			memcached and redis are examples of in-memory caching.
			it stores key-value between application and database.
		2. database caching :
			Database caching is a mechanism that generates web pages on-demand (dynamically) by fetching the data from the database.
		3. web server caching : 
			Web server caching is a mechanism that stores data for reuse.
			It is cached for the first time when a user visits the page. If the user requests the same next time, the cache serves a copy of the page
		4. CDN caching : 
			It is a component used in modern web applications. It improves the delivery of the content by replicating commonly requested files (such as HTML Pages, stylesheet, JavaScript, images, videos, etc.) across a globally distributed set of caching servers.
			The CDN reduces the load on an application origin and improves the user experience. It delivers a local copy of the content from a nearby cache edge (a cache server that is closer to the end-user), or a Point of Presence (PoP).
	
	spring boot cache annotation : 
		@EnableCaching : 
			class level annotation
			to enable caching in the spring boot we use this annotation.
			It is defined in cache.annotation package.
			Used with @Configuration class. The same class with @SpringBootApplication.
			The auto-configuration enables caching and setup a CacheManager, if there is no already defined instance of CacheManager. It scans for a specific provider, and when it does not find, it creates an in-memory cache using concurrent HashMap.
		
		@CacheConfig :
			It is a class-level annotation that provides a common cache-related setting. It tells the Spring where to store cache for the class. When we annotate a class with the annotation, it provides a set of default settings for any cache operation defined in that class. Using the annotation, we need not to declare things multiple times.
		
		@Caching : 
			this annotation is used when we need both annotations @CachePut or @CacheEvict at the same time on the same method.
			But Java does not allow multiple annotations of the same type to be declared for a given method. To avoid this problem, we use @Caching annotation.
			
		@Cacheable : 
			method level annotation
			defines a cache for a method's return value.
			The Spring Framework manages the requests and responses of the method to the cache that is specified in the annotation attribute
			We can also apply a condition in the annotation by using the condition attribute. When we apply the condition in the annotation, it is called conditional caching
			
		@CacheEvict : 
			It is a method level annotation. It is used when we want to remove stale or unused data from the cache. It requires one or multiple caches that are affected by the action. We can also specify a key or condition into it. If we want wide cache eviction, the @CacheEvict annotation provides a parameter called allEntries. It evicts all entries rather than one entry based on the key.

			One important point about @CacheEvict annotation is that it can be used with void methods because the method acts as a trigger. It avoids return values. On the other hand, the annotation @Cacheable requires a return value that adds/updates data in the cache. 
		
		@CachePut : 
			It is a method level annotation. It is used when we want to update the cache without interfering the method execution. It means the method will always execute, and its result will be placed into the cache. It supports the attributes of @Cacheable annotation.

			A point to be noticed that the annotations @Cacheable and @CachePut are not the same because they have different behavior. There is a slight difference between @Cacheable and @CachePut annotation is that the @Cacheable annotation skips the method execution while the @CachePut annotation runs the method and put the result into the cache.
	
	If we want to enable cache mechanism in a Spring Boot application, we need to add cache dependency in the pom.xml file. It enables caching and configures a CacheManager.
		spring-boot-starter-cache
cache vs buffer : 
	https://www.javatpoint.com/spring-boot-caching
spring boot cache provider : 
	spring boot framework allows the integration of various cache providers.
	The cache providers allow the developers to configure cache transparently and explicitly in an application.
	cache is used because it improves the performance of the application.
	
	The cache abstraction does not provide the actual space in spring boot.
	It depends on the abstraction that occured by the cache.Cache or cache.CacheManager interfaces.
	
	caching auto-configuration : 
		the spring boot provides auto-configuration support which simplifies the implementation of caching.
		It searches for the libraries and configuration-files in the classpath and initializes the required dependency beans at the time of application startup 
		The auto configuration of startup include following steps : 
			add annotation @EnableCaching in the configuration file
			add required caching libraries in the class path
			in the root of the classpath, add the configuration file for the cache provider.
		Incase of more than one cache providers available, we must specify the cache provider explicitly in the application.properties file.
		
changing port number of spring application : 
	spring boot provides default embedded server to run spring boot application(tomcat server)
	By default spring boot application runs on port 8080
	how to change the port number :
		1. using application.properties :
			Recommended way to change the port number.
			To change the port number we need to use the following property : 
				server.port = 8180
			We can set the port to 0.
			If the port is set to 0, it will scan random port for application. It uses new port whenever we restart the application.
		2. using application.yml file :
			this is similar to the application.properties, only difference is that the format of the file is yml.
		3. using EmbeddedServletContainerCustomizer Interface :
			For spring boot 1.x version, it provides an embeddedServletContainerCustomizer interface to change the default port.
			using this we can customize auto-configured embedded servlet containers.
			All the beans of this type get a callback with the container factory before starting the container itself. Therefore, we can set the port, addresses and even the error pages.
			The interface contains a method called customize(). 
			It allows us to customize and specify configurableEmbeddedServletContainer.
			It parses a parameter called container that we want to customize.
			It contains a method called as setPort() that is used to change the port. By default, when not specified, it uses port 8080. To disable the auto-start feature of the embedded server, use the port -1. -1 represents that it will start the web application context but will not listen to any port. The setPort method is to be called within the customize method that we should override.
		4. using webServerFactoryCustomizer interface :
			Spring boot 2.x version provides webServerFactoryCustomizer interface to change the default port. It is defined in the package boot.web.server.
			It takes we server factory type as input.
			similar to embeddedServletContainerCustomizer, we have a customize method that we need to override and inside that method we need to call the setPort method. 
			This method will set the port and if we set it to -1 then it will not listen to the port but the application context will start.
		5. using command-line parameter :	
			We can set the port using command line argument.
			We need to set the --server.port=portNumber in the arguments.
			eg.
				java -jar springJar.jar --server.port = portNumber

Spring boot rest example : 
	We use rest applications for developing and designing networked applications.
	It generates the HTTP requests that performs CRUD operations on the data.
	Usually it returns data in JSON and XML format
	
RESTful web services : 
	what are restful web services : 
		restful web services are client and server applications that communicate over www.
		These web services are based on REST architecture
		RESTful web services provides communication between software applications running on different platforms and frameworks
		
	What is rest architecture : 
		In rest architecture everything is a resource.
	
	what is a web service : 
		web services are the types of internet applications that make use of standardized messaging protocol over the distributed environment.
		It integrates web-based application using REST, SOAP, WSDL and UDDI over the network.
		Example : 
			java web service can communicate with .net application.
		
		what is UDDI(universal description, discovery and integration) : 
			UDDI is an XML-based standard for discribing, publishing and finding web services.
			UDDI stands for : 
				universal description, discovery and integration
			UDDI is a specification for a distributed registry of web services
			UDDI is a platform-independent, open framework
			UDDI can communicate via SOAP, COBRA, Java RMI protocol.
			UDDI uses web service definition language(WSDL) to describe interfaces to web services.
			UDDI is seen with SOAP and WSDL as one of the three foundation standards of web services.
			UDDI is an open industry initiative, enabling businesses to discover each other and define how they interact over the internet.
		features of web services : 
			web services are designed for application to application interaction.
			it should be inter-operable
			it should allow communication over the network
			web service can be called from different platforms
			
		The web service must be able to fulfill the following conditions : 
			1. web service must be accessible over the internet
			2. it is discoverable through a common mechanism like UDDI
			3. it must be interoperable over any programming language or operating system.
		
		Uses of web services : 
			web services are used for reusing the code and connecting the existing programs.
			can be used to link data between two different platforms
			provides interoperability between separate applications.
		
		Input to a web service is called a request
		Output of a web service is called a response
		
		There are two popular formats of request and response : 
			XML :
				XML format is popular form of request and response in web-services.
			JSON :
				JSON is a readable format for structuring data. It is used for transiting data between server and web application.
		
		To make a web service platform independent, we make the request and response platform independent
		
		One question is that how does the client know about the format of the response and request.
		For this, we have service definition. Every web service offers a service definition. It specifies the following things : 
			request/response format 
			request structure
			response structure
			endpoint
		
		
		key terminology of web services : 
			request and response : 
				request is the input to the web service and response is the output from the web service
			message exchange format (XML and JSON) : 
				It is the format of the request and response.
			service provider or server :
				server is the one that hosts the web service
			service consumer or client : 
				client is the one that uses the web service
			service definition : 
				service definition is the contract between the service provider and service consumer.
				service definition defines the format of request and response, request structure, response structure and endpoint.
			transport : HTTP and MQ : 
				transport defines how a service is called.
				There are two popular ways of calling a service : 
					HTTP and MQ(message queue)
				By using the url of the service, we can call the service over the internet.
				Message queue communicates over the queue. The service requester puts the requests in the queue.
				The service provider listens to the request, process the request, creates the response and puts the response back in the MQ.
		
		characteristics of web services : 
			web services have following characteristics : 
				XML based : 
				coarse-grained :
				loosely coupled :
				capability to be synchronous and asynchronous : 
					synchronous web services are served by RPC-oriented messaging.
					the documented-oriented messaging is often used for asynchronous web services.
				supports RPC :
		
		architecture of web services : 
			The architecture of web services interacts among three roles : 
				service provider :
					platform that hosts the service
				service requester : 
					its an application that is looking for or invoking or initiating an interaction with a service.
				service registry
			The interaction involves three operations : 
				publish (publication of service desciption) : 
					a service desciption must be published so that the service requester can find the service
				find (finding of service description) :
					service requestor retrieves the service description directly
				bind (invoking of service based on service desciptions) :
					in this, the service requestor invokes or initiates an interaction with the service at runtime using the binding details in the service desciption to locate, contact and invoke the service
			These operations and roles act upon the web services artifacts.
			The web service artifacts are the web service software module and itss description.
		
		Web service implementation lifecycle : 
			phases : 
				requirement phase
				analysis phase
				design phase
				coding phase
				test phase
				deployment phase
				
		types of web services : 
			RESTful web services :
				Representational state transfer 
				main goal : to make web services more effective
				RESTful web services try to define services using the different concepts that are already present in HTTP.
				REST is an architectural approach not a protocol
				It does not define a standard message exchange format. We can build REST services with both XML and json.
				
				The key abstraction is a resource in REST.
				A resource can be anything.
				We can access resource using a Uniform resource indentifier (URI)
				when we request a resource, we provide the representation of the resource.
				The important methods of HTTP are : 
					put
					post
					get
					delete
				HTTP standard status code : 
					404 : resource not found
					200 : success
					201 : created
					401 : unauthorized
					500 : server error
				
				RESTful service constraints :
					1. There must be a service producer and service consumer
					2. service is stateless
					3. service result must be cacheable
					4. interface is uniform and exposing resource
					5. service should assume a layered architecture
				advantages of RESTful web services : 
					1. RESTful web services are platform-independent
					2. can be written in any programming language
					3. provides different data format like JSON, text, HTML and XML
					4. it faster than SOAP because it does not have strict specifications
					5. these are reusable
					6. language neutral
			SOAP web services : 
				REST defines an architectural approach whereas SOAP poses a restriction on the format of the XML.
		
		web services components : 
			there are two components of web services : 
				web service description language (WSDL) :
					WSDL is an XML based interface description language.
					used for describing functionality offered by a web service.
					a.k.a WSDL file
					extension of this file is .wsdl
					It provides a machine-readable description of how the service can be called, what parameter it expects and what data structure it will return
					describes service as a collection of network endpoint or ports.
					often used in combination with SOAP and an XML schema to provide XML service over the distributed environment.
					the purpose of WSDL is similar to type-signature in a programming language
				universal description discovery and integration (UDDI) :
					UDDI is an XML-based standard for discribing, publishing and finding web services.
					UDDI stands for : 
						universal description, discovery and integration
					UDDI is a specification for a distributed registry of web services
					UDDI is a platform-independent, open framework
					UDDI can communicate via SOAP, COBRA, Java RMI protocol.
					UDDI uses web service definition language(WSDL) to describe interfaces to web services.
					UDDI is seen with SOAP and WSDL as one of the three foundation standards of web services.
					UDDI is an open industry initiative, enabling businesses to discover each other and define how they interact over the internet.
		difference between SOAL protocol and RESTful web services :
			https://www.javatpoint.com/restful-web-services-difference-between-soap-and-rest
			
		Autoconfiguration of HttpMessageConvertersAutoConfiguration which is done automatically by @SpringBootApplication annotation, automatically converts the message.
		It initializes the Jackson bean and the message converter. The Jackson2ObjectMapper does the conversion from bean to json and json to bean
		
		ResponseEntity class :
			extends httpEntity and httpStatus class.
			used in restTemplate and @Controller methods
			also used in spring MVC as a parameter in a @Controller method
		
		exception handling : 
			If there is an exception we should throw an exception.
			we need to create a new class which extends RuntimeException.
			Now we can annotate this class with @ResponseStatus()
			In the @ResponseStatus() we can pass the HttpStatus enum which we can use to return status response.
			
			How to implement generic exception handling for all resources : 
				create a new class 
				at the basic level, there are three crucial things for the exection structure : 
					timestamp 
					message
					detail
				The structure is most important part and must be language independent
				We need to extend ResponseEntityExceptionHandler abstract class from the spring framework which provides centralized exception handling. 
				This exception handling functionality is applied to all the controllers
				We need to create a new class with name CustomizedResponseEntityExceptionHandler which will extend ResponseEntityExceptionHandler class
				add @ControllerAdvice and @RestController annotation
		
		validation for RESTful services : 
			java validation api to add validation in our beans file
			Add @Valid annotation. It is a Javax validation API. Its default classpath is spring-boot-starter-web. We need to use this annotation on the parameter of the controller method. 
				eg. ResponseEntity(Object) createUser(@Valid @RequestBody User user)
			now in the User class, we need to add annotation on the variable. We need to annotate the variables with annotations like,
			@Size(min = 5)
			@Past (this is for date)
			
			
		Internationalization of RESTful services : 
			Internationalization is the process of designing web applications or services in such a way that it can provide support for various countries, various languages automatically without making the changes in our application.
			a.k.a I18N because the word internationalization has total 18 characters starting from I to N.
			
			localization is performed by adding locale-specific components such as translated text, data describing locale-specific behavior, etc. 
			
			Java provides the foundation of internationalization for desktop and server applications. There are following important internationalized areas of functionality : 	
				text representation : java is based on unicode character set and several libraries implement the unicode standard
				locale identification and localization :  Locale in java are identifiers that can be used to request locale-specific behavior in different areas of functionality
				date and time handling : java provides various calendars. It supports conversion to and from calendar independent date objects. Java supports all the timezones in the world.
				text processing : It includes character analysis, case mapping, string comparison, breaking text into words, formatting numbers, dates, and time values into strings or parsing them back from strings. Most of these functions are locale-dependent
				character encoding : It supports converting text between unicode and other character encodings when reading incoming text from the streams or writing outgoing text to the streams.
				
		content negotiation : 
			a resource can have many representations, mostly because there may be multiple clients expecting different representation.
			content negotiation is the process of selecting the best representation for given response when there are multiple representations available.
			We can define the content-type in the header of the http request.
			Http header Accept is used to determine what type of representation is desired at the client-side.
			We can define the preference using the q parameter.
			eg. 
				Accept : application/json, application/xml;q=0.7,*/*;q=0.5
			If the service created returns JSON type but the header is accepting only application/xml, it will return the status:406 Not acceptable.
		
		Implementing static filtering for RESTful services : 
			filers are one of the important features provided by the JAX-RS framework.
			It can be applied to either request to a resource or response from a resource, or to both.
			We use filtering when we want to show only some class members in the response. 
			Jackson has two annotations that are used in filtering : 
				@JsonIgnore : 
					member or method level annotation
					it expects that the properties to be excluded are marked one by one.
					if we want to eliminate a member from the process of serialization and deserialization, we can annotate the actual property or its setter or getter
					eg : 
						@JsonIgnore
						private String salary;
				@JsonIgnoreProperties : 
					class level annotation
					it ignores the logical properties in json serialization and deserialization
					eg: 
						@JsonIgnoreProperties({"var1", "var2"})
						public class someBean {
							private type var1;
							private type var2;
						}
			
			Suppose we want to filter  the property in one scenario and we dont want to filter it in another scenario then we cannot use static filtering.
			In this scenario we need to use dynamic filtering.
		
		Implementing dynamic filtering for RESTful services : 
			for this we use MappingJacksonValue class which make use of the filterProviders to filter the response.
			
		Versioning in RESTful web services : 
			When the users are using the api and we make a breaking change in the api, now some users want to use the new apis but some users want to continue using the same api. In this scenario we want to implement versioning.
			what are breaking changes : 
				a change to the format of response for one or more api calls
				change in the response type
				remove any part of the api
			breaking change should always result in a change in the major version number for an API or content response type.
			how to version :
				commonly used approaches fall into three categories : 
					URI versioning :
						most straightforward approach
						specifies the version in the url as a query string.
						guaranteed to break the client integration when a version is updated.
						twitter uses this type of versioning
						eg : 
							http://api.demo.com/v1
							http://apiv1.demo.com
						
						to implement this, we just need to create two separate handlers in the controller class with separate endpoints
					versioning using custom request header : 
						a custom header allows us to preserve the urls.
						it a copy of the content negotiation behavior implemented by the existing accept header.
						version information is specified in the request header without the need for any change in the url.
						microsoft uses this type of versioning
						User cannot access the request header versioning in the normal browser, we need a special plugin to access them on the browser
						eg : 
							Accept-version: v1
							Accept-version: v2
							
						to implement this : 
							add the headers parameter in the @GetMapping annotation
							eg : 
								@GetMapping(value = "/person/header", headers = "X-API-Version = 1")
								
								In the request header : 
									add the key : X-API-Version
									and value : 1
						
					versioning using request parameter : 
						to implement this, 
						change the endpoint to use the same string.
						After the endpoint is similar, in the @GetMapping annotation add a parameter :
							params = "version=1"
						
							eg. 
								@GetMapping(value = "/person/param", params = "version=1")
								
								request url :
									http://localhost:8080/person/param?version=1
									
					versioning using accept header : 
						accept header define the media type and character encodings
						we can also pass version information for web api through accept headers without changing the url.
						AKA media type versioning or content negotiation or accept header.
						github uses accept header versioning.
						eg : 
							Accept: application/vnd.demo.v1+json Accept:application/vnd.demo+json;version=1.0
						
						to implement this : 
							use the produces parameter of the @GetMapping annotation 
							eg: 
								@GetMapping(value = "/person/produces", produces = "application/vnd.company.app-v1+json")
								
								in the request header :
									add the key : Accept
									and set the value : application/vnd.company.app-v1+json
		
		implementation of basic authentication :
			In basic authentication, we send the username and password as part of our request. When the username and password is provided, we can access the resources
			There is advanced form of authentication like digest authentication. where the password digest is created and the digest is sent across not the password to the server.
			There is also OAuth (open authentication) or OAuth2 authentication
			
			basic authentication : 
				adding the following dependency automatically configures the basic security for us : 
					<dependency>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-starter-security</artifactId>
					</dependency>
				when we start the application, in the log, a password is generated.
				While making an API request, we need to send the username and password
				in the authorization section, we need to set the user name and the password and use the type as Basic Auth.
				The password that is generated is a random password and will change on restart. To set a custom username and password, we need to set the following properties in the application.properties :
					spring.security.user.name = user
					spring.security.user.password = password
		
		Best practices of RESTful web services :
			The first and last best practice is the consumer first.
			meaning always thing about the consumer before naming the resources, think from the perspective of the customers, what do they thing about those resources, will they be able to understand those resources.
			
			consumer first : 
				must have excellent documentation for our API
				swagger is one of the most popular documentation standard for RESTful api.
				make sure the consumer understands our documentation
			
			make best use of HTTP : 
				RESTful web services are based on Http
				make best use of the request methods.
				use right request method, appropriate for our specific action and ensure that we are sending proper response status back
				ensure that there is no secure information in the uri
				when we think about resources, always use nouns for the resources. But it is not always possible. There are always exception scenarios. For all these exceptions scenarios, define a consistent approach if we are searching through user use /user/search.
SOAP web services : 
	SOAP stands for simple object access protocol.
	it is an xml based protocol for accessing web services
	SOAP is W3C recommendation for communication between two applications.
	platform and language independent
	Using soap we can interact with other programming language applications.
	advantages of soap : 
		soap provides its own security called as WS security
		language and platform independent
	disadvantages of soap : 
		SOAP uses XML format which must be parsed to be read. It defines many standards that must be followed while developing SOAP applications. So it is slow and consumes more bandwidth and resources
		SOAP uses WSDL and doesnt have any other mechanism to discover the service.

swagger :
	swagger is an open source tool
	It is most popular API documentation format for RESTful web services.
	provides both JSON and UPI support.
	The main swagger tools are : 
		swagger ui : It creates interactive API documentation
		swagger editor : browser-based editor where we can write OpenAPI specification
		swagger codegen : it generates server stubs, and client libraries form an openAPI specification
	
	An openAPI specification formerly known as swagger specification is an API documentation format for REST APIs. An open api file allows us to describe our entire API, including : 
		available endpoints(/users) and operations on each endpoint(GET /users, POST /users)
		operation parameters for each operation
		authentication methods
		contact information, license, term of use and other information.
		
	Generate swagger documentation for our RESTful service :
		add the dependency for swagger in pom.xml file : 
			<dependency>  
				<groupId>io.springfox</groupId>  
				<artifactId>springfox-swagger2</artifactId>  
				<version>2.9.2</version>  
			</dependency> 
		add swagger ui dependency :
			<dependency>  
				<groupId>io.springfox</groupId>  
				<artifactId>springfox-swagger-ui</artifactId>  
				<version>2.9.2</version>  
			</dependency>  
		create a class with name swaggerConfig.java and add the following two annotations on the class : 
			@Configuration
			@EnableSwagger2
		In the same class add a bean method with @Bean annotation which will return :
			new Docket(DocumencationType.SWAGGER_2);
		
		Run the application
		we can access the api documentation using the url : 
			localhost:8080/v2/api-docs
		we can access the swagger ui using the url : 
			localhost:8080/swagger-ui.html
	
	Swagger is a specification for documenting REST API. 
	It specifies the format(URL, method and representation) to describe REST web service.
	It provides tools to generate/compute the documentation from the application code.
	
	Swagger scans application code, and exposes the documentation on URL. A client can consume this URL and learn how to use REST web services: which HTTP methods to call on which URL, which input documents to send, which status code to expect, etc.

creating many to one relationship : 
	we have two entities : 
		post and user
	
	the post entity have the following fields : 
		integer id
		string description
		User user
	
	In the post entity, we need to annotate the user entity as @ManyToOne annotation because a user can do many posts.
	So the post entity will have : 
		@ManyToOne(fetch=FetchType.LAZY)
		User user;

	we have configured the relationship on the post side now we want to configure is the user side.
	
	A user can have multiple posts, therefore, in the user entity, we have a list of Post and @OneToMany annotation with propery (mappedBy="user"), this will create a relationship column in the post entity.
	So the user entity will have : 
		@OneToMany(mappedBy="user")
		private List<Post> posts;
		
Richardson Maturity model:
	this model grades API by their RESTful maturity.
	this model is a way to grade your API according to the constraints of REST.
	It breaks down the principal element of the REST approach into four levels(0 to 3)
	levels of REST approach : 
		level 0 : swamp of POX
		level 1 : resources 
		level 2 : HTTP verbs
		level 3 : hypermedia control
	lower the level, lower is the RESTfulness
	When API reaches level 3, we consider it as RESTful API.
	
	level 0 :
		plain old XML (POX)
		at this level, HTTP is only used as a transport protocol that is used as a remote interaction
	https://www.javatpoint.com/restful-web-services-richardson-maturity-model