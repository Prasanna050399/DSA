Personal : 

Release : 23 / 01 / 1996

Introduction : 
	Class is the blueprint or model for creating the objects.
	
	JVM will allocate/deallocate the memory needed by a java program.
	
	which part of jvm will allocate the memory needed for java program??
		Class loader subsystem of jvm will allocate the necessary memory needed by the java program.
		https://www.geeksforgeeks.org/classloader-in-java/
	
	For deallocating the memory garbage collector of jvm is used. The algorithm that is most commonly used by garbage collector is "mark and sweep". 
		https://www.geeksforgeeks.org/mark-and-sweep-garbage-collection-algorithm/
=====================================================================================================================
Coursera	
Classes:
	Classes are user defined data types.
	So we define the behaviour of the class by defining the attributes and the methods of the class.
	Its like a factory, it can produce a piece of data with a template that we define.
	A class is a type of data.
	In java the filename of the code should be same as that of  class name.
	syntax:
		access-specifier class classname
		{
			class definition
		}
		
	Member/instance variables:
		These are the variables defined inside the class but outside the function.
		These are the variables that are accessible throughout the class.
		This is the data the object needs to store.
		syntax:
			access-specifier datatype variable_name;
	
	Methods:
		Methods represents the behaviour of the class. How the data will be used etc.
		These are the functions that interact with the member variables.
		Parameters in java are always passed by value and not by reference.
			So even if we are writing a variable name as an argument, we are passing it by value and not by reference meaning the name of the variable is first evaluated and then passed to the function. Just like python where the variable is passed by object reference.
		
		No these are the things that are important for defining a function:
			1. access-specifier
			2. return type
			3. function name
			4. Paranthesis() with optional parameters
			5. curly braces
			6. exception handler which is optional.
		syntax:
			access-specifier return_type function_name(parameters...)
			
	Constructor:
		These are the functions that are automatically called when the object is created.
		These are the methods with the same name as that of the class. And does not have a return type. Constructors can only be public meaning the access-specifier is public.
		These methods are used to initialize the member variables.
		When the constructor is over, meaning it is finished executing, the variable are removed from the scope. Because when a method ends its scope disappears.
		syntax:
			access-specifier classname()
		
		Types of constructors:
			1. Default constructors:
				This is the constructor which do not take any parameters.
			2. Parametrized constructors:
				This is the constructor which takes parameters.
	
	this keyword:
		It is similar to self in python.
		'this' refers to the calling object, which is the object that called the method, on which the method was called.
		'this' stores the reference of the object that is created. With this we can say that it is literally the copy of 'self' which we learned about in python.
		Also 'this' have a local scope.

Object:
	This is the instance/example of the class. 
	It is a piece of data that the factory created. It is one piece of data of class type of data.
	Each individual object can be customized and changed without affecting other objects.
	Whenever a new object is created it is stored in a heap.
	So when an object is created, the reference of that object is stored in our variable.
Packages:
	Packages organizes java classes into namespaces. Classes in packages can access package-private and protected members. Basically package is a collection of classes.
Access specifier:
	These are the keywords with which specifies where the given variables will be accessible from.
	types:
		public:
			This means that the given variable can be accessed from any class.
			Meaning we can access and control the value of instance variable from other classes.
			Consider we have a main method in some other class.
			We can access the variable and set its value using the object of the respected class.
			eg.	
				Classname ob1=new Classname; ---> this is the creation of an object
				ob1.var=10;
				System.out.println(ob1.var);
			Similar to variables, methods can also be public. This is used often because we want to access the functions from the main function.	
			
		private:
			This means that the given variable is accessible only within the same class it is declared in.
			We cannot access these variables using the object. Same thing goes for methods if we make a method private it cannot be accessed from outside the class.
			This is very useful when we want to control the access of variables.
			Private methods are used as a helper methods.
			Trying to access the private member of a class leads to a compile time error.
		protected
		
getter and setter:
	These are the methods which as the name suggest are used to get the value of the data member or set the value of the data member. The variable can be returned using the getter function. On the other hand we can set the value of a private member from outside the class using the setter variable.
	Then the question is if we are providing access to the variable then why dont we make the variable public in the first place?
	The setter functions allow us to get more control over the variable. We can apply insertion constraints, we can only provide this function to selected users etc.
	These are the methods which as the name suggest are used to get the value of the data member or set the value of the data member. The variable can be returned using the getter function. On the other hand we can set the value of a private member from outside the class using the setter variable.
Variables:
	syntax:
		datatype variable_name;
		
	types of variables:
		1. Local variables:
			These are the variables which are only valid or accessible inside that block.
		2. Parameters :
			These are similar to local variables. These are also valid only inside the block and also inaccessible outside the block/function.
		3. Member variable:
			These are the variables which are defined inside the class and are accessible depending on there access specifier. So if the variable is public it is accessible from anywhere eg. from another class. If the variable is private it is accessible only within the class. And if the variable is protected it is accessible within that class and the child class meaning the class which inherited the given class.

Array:
	syntax:
		return_type var[] = new return_type[size];
	In java the arrays are always initialized by the return type. Meaning if array is of type int, the array is initialized to 0, if float the value will be 0.0 and so on.(For Bool it is false.)
	
Method overloading:
	Method overloading is the technique when we define different functions with the same name but with different number of parameters or the datatype of parameter is different.
	Java wont allow different return type as a way to overload methods.	 But we can use different return types while overloading although it is not used to overload a function. 
	This is because when javac compiler is compiling a code, it takes help of the argument list and not the return type list. This is the reason we cannot overload a function using only the return type of the function.
	We can also overload constructors for this we use different number of parameters since constructors dont have a return type.
	
Lists in java:
	List is a java interface. Its an abstract data type. 
	And since its an interface, it specifies a certain behaviour but does not define how that behaviour is implemented.
	
	ArrayList:
		ArrayList a class that implements all the behaviour of the list interface.
		ArrayLists are resizable. Just like lists in python.
		It is an ordered collection.
		How to define an arraylist?
			ArrayList<datatype,...> variable = new ArrayList<datatype,...>();
		set():
			This function is used to modify an element in the array list.
			This function take 2 arguments,
			1. The index at which we want to store the element.
			2. The element itself.
			eg.	
				var.set(0,x);
		size():
			In array we use length attribute. In arraylist, we use the size method to retain the size of the list.
			eg.
				var.size();
		add():
			Now this method is overloaded. There are 2 methods named as add one with boolean return type and second with void return type.
			If we use one argument, the return type is boolean and it append the given element at the end of the array list.
				eg.
					var.add(x);  --> similar to append in python
			If we use two arguments, then the return type is void and it enters the given element at the given position.
				eg.
					var.add((int) index,element); --> similar to insert in python
		get():
			This method takes the index of the list and returns that element of the list.
				eg.
					var.get(index);  --> Note this method return type is generic, it returns element of the type that is specified by us while declaration.
		remove():
			This method is used to remove the element at the given index.
		
		We can use the for each loop to access the elements of the arraylist.
		
		clear():
			This function is used to clear the entire list.
			eg.
				var.clear();
	Collections.sort():
		To sort an arraylist we need to use the Collections class. The Collections class contains a static method known as sort() which takes an arraylist as an argument. 
		eg.
			Collections.sort(arr1); --> here arr1 in an arraylist.
			
		If we want to sort an implementation of List for example ArrayList(), then we need to provide an implementation of Comparator interface. 
			Collections.sort(arr1, comparatorImplementation);
			
	Comparator interface :
		This is a functional interface as well just like comparable.
		We need to implement the following method :
			int compare(object1, object2);
		
		Therefore we can implement a lambda which will take two objects as input.
		
		The compare method will return :
			-1 : if first object is less than second 
			0  : if both objects are equal
			1  : if first object is greater than second
		
	

	sorting an array :
		to sort an array we can call : 
			Arrays.sort(variableName);
		If we want to sort the array where the type of array is userDefined(class), then we need to implement the comparable interface.
		Our class will override the compareTo method and the Arrays.sort() method will be able to sort the array.
	
	Comparable interface :
		this is a functional interface that has the method :
			int compareTo(<?> obj);
		This method is used for comparing two objects.
		If we want to sort a array of user defined objects, we need to implement Comparable interface.
		Class className implements Comparable {}
		Then we can call 
			className[] variableName = new ClassName[]();
			Arrays.sort(arrayVariable);
		
		the method should return -ve number if the current object is smaller than the given object
		the method should return +ve number if the current object is greater than the give object 
		0 if the two objects are equal.
			
			
	LinkedList:
		Similar to the array list we also have linked list.	
		How to create a linkedlist?
			eg.
				LinkedList <datatype,...> variable = new LinkedList<datatype,...>();
				
		addFirst()	Adds an item to the beginning of the list.	
		addLast()	Add an item to the end of the list	
		removeFirst()	Remove an item from the beginning of the list.	
		removeLast()	Remove an item from the end of the list	
		getFirst()	Get the item at the beginning of the list	
		getLast()	Get the item at the end of the list
		
	
HashMap:
	We can use HashMaps to implement hashing in java.
	The Hashmap is a key value pair.
	It is unordered.
	How to define HashMap?
		HashMap<key_datatype,value_datatype> variable = new HashMap<key_datatype,value_datatype>();
	
	put():
		This method is used to add an element in hashtable.
		The function takes two parameters. The key and the value.
		eg.
			variable.put(key,value);
			
	get():
		This method is used to access the element of the hashmap.
		It takes a single argument, the key.
		eg.
			var.get(key);
		
	remove():
		This method is used to remove the key and its value.
		It takes the key as parameter.
		eg.
			var.remove(key);
			
	size():
		This returns the size of the hashmap.
		eg.
			var.size();
	clear():
		This is used to clear the entire hashmap.
		eg.
			var.clear();
			
	keySet() and values():
		We can use these to iterate using for each loop.
		eg.	
			for(key_datatype x : variable.keySet())
		same goes for values.
		
HashSet:
	This is like set in python
	this is unordered
	How to define a hashset?
		HashSet <datatype> var = new HashSet<datatype>();
		
	add():
		To insert element in the hashset
	contains():
		To check if a given element is in the hashset
	remove():
		To remove an element.
	size():
		returns the size of the set.
Loops:
	For each:
		Syntax:
			for (data_type var : iterable(array list etc))
			{
				code;
			}
		This is similar to for each loop in python.
		
		
SOLID JAVA Code:
	S : Single responsibility Principle
	O : Open close principle (open for extension closed for modification)
	L : Liskov Substitution Principle
		LSP ensures that derived classes can be used in place of their base classes without causing errors or changing the program's behavior.
		It emphasizes that subclasses should be able to take on the responsibilities of their superclass without any side effects.
	I : Interface Segregation Principle
		ISP splits large interfaces into smaller, more specific interfaces.
		This allows clients to only know about the methods that are relevant to them.
		ISP helps keep code clean and easy to work with. 
	D : Dependency inversion Principle
		High-level modules don't depend on low-level modules: Major functionalities shouldn't be affected by implementation details. 
		Abstractions don't depend on details: Instead, details should depend on abstractions. 
		Use interfaces: Program to interfaces instead of implementations. This allows for greater flexibility, maintainability, and testability. 

Polymorphism:
	1. Overloading:
		a. Static binding (compile time polymorphism)
		b. Same name but different method signature
		c. Same class
		d. Faster than overriding
	2. Overriding:
		a. Dynamic binding (run time polymorphism)
		b. Same name and same method signature
		c. Different Class
		d. Cannot reduce accessibility of the overridden method. Meaning if method is public in parent class then it cannot be protected, private or class private.
		e. But we can increase the accessibility of the method meaning if it is protected we can make overridden method public.
		f. Cannot override private, static, and final method 
		g. Slower than overloading.


final:
	Final keyword is used to restrict a class,method or variable from the user.
	
	final variable:
		this variable cannot be changed. It can only be initialized in the constructor. It cannot be edited.
		blank final variable is a final variable which is uninitialised. So to initialize this we need to use constructor. This variable cannot be changed after this.
	final method:
		this method cannot be overridden.
	
	final class:
		this class cannot be extended.

Abstract:
	abstract class:
		abstract class is the class that cannot be instantiated. However we can inherite it.
		this is like the blue print of the class. It tells the class what to do but not how to do.
		if the inherited class does not provide the defination of abstract method then in that case the inherited class must also be declared as abstract.
		This class can have all normal methods as well. We can also declare normal variables with normal access specifier.
		
	abstract method:
		The method without a body and is preceeded by abstract keyword.
		eg : 
			abstract void methodName();	
		
fundamental difference between abstract class and interface : 
	The fundamental difference between an abstract class and an interface is that an abstract class can provide partial implementation of methods, including concrete methods with code, while an interface only defines method signatures without any implementation, essentially acting as a contract that classes must adhere to when implementing it; meaning an abstract class can provide some shared functionality while an interface only specifies required behaviors without dictating how to achieve them. 
	
Interfaces:
	This defines the behaviour that a class must implement.
	Like abstract classes, interfaces cannot be used to create objects (in the example above, it is not possible to create an "Animal" object in the MyMainClass)
	Interface methods do not have a body - the body is provided by the "implementing+" class
	On implementation of an interface, you must override all of its methods
	Interface methods are by default abstract and public
	Interface attributes are by default public, static and final
	An interface cannot contain a constructor (as it cannot be used to create objects)
	
Method hiding:	
	If we implement a method with same signature and name as that of parent class, but the difference is that the methods are static.
	In this case the child class method hides the parent class method. However we can still call the method using the name of the class.

Graphical User interface(GUIs):
	
	
	
	
====================================================================================================================================================================
The internet made java.

What is local variable type inference ?
	It allows the programmer to define a variable without specifying the type of it using the var keyword.
	The compiler will infer the type of the variable based on the value that is provided to it.
	The idea is that if the type of the variable should be same or compatible for both left hand and right hand side then we can use this to define the type of variable using the rhs.
	This feature was introduced in java 10.
	
	declaration :
		var idenifier = value;
	
	We cannot just declare the variable we need to initialize it as well in the same line.
	
	restrictions :
		1. only one variable can be declared at a time using var.
		2. we cannot write the [] in front of identfier or the var keyword while defining array.
		3. it requires initializer. Only declaration is not allowed.
		5. cannot use null as initializer.
		6. cannot use var keyword with an array initializer.
		7. var cannot be written as a name of a class, interface, enumeration, annotation or generic type parameter.
		8. var cannot be used to declare the exception type caught by the catch block.
		9. also neither lambda expressions nor method references can be used as initializer.
	
History and evolution : 

	Any computer language innovation and development occurs for two fundamental reasons : 
		1. To adapt to changing environment and uses
		2. To implement refinements and improvements in the art of programming
	The development of java was driven by both of these elements in nearly equal measure.
	C was invented to have a high level programming language which can be used to create a computer program with medium complexity, basically a need for structured language. 
	C ++ was invented to have a high level programming language which can be used to create a compute program with high level of complexity, basically a need for object oriented programming language.
	Java was invented to have a high level programming language which can be platform independent. The initial requirement was to provide support for different processors because different processors will need different compilers which are expensive to create. But then the internet came which had this requirement of programs being platform independent. This catapulted the java language to its glory/under the focus light. When we are saying platform independent we also mean architecture-neutral programming language (the one which is independent of the processor)
	c# is created by microsoft to support the .net framework. c# is closely related to java.
	
	Java also addressed couple of biggest issues associated with the internet, them being :
		portability and security
	
	
Java Applets :
	Applets are java programs that are designed to be transmitted over the internet and automatically runs on the browser which is compatible.
	Used to display the data from server, take user inputs, basically small functions that could be executed on local instead of server.
	If the user clicks on a link that contains an applet, the applet will get downloaded and run on the browser. Seems like security problem to me.
	There are two types of objects that are transmitted between the server and the client : 
		passive information :
			emails, programs on there own, text messages basically static data 
		dynamic, active programs : 
			applets, self executing programs because these are active agents on the client computer, but are initiated by the server.
	
	
	Security : 
		The problem with applets or lets say any dynamic, active programs/objects which are transmitted on the internet and executed on the client browser is security. Because these are programs that are running on client computer but initiated by server. 
		
		Java dealt with this problem by confining the execution of a program to the Java execution environment. So the programs running on java execution environment will not have any access to the files on the computer. Thus providing the security.
		
	Portability : 
		The issue with portability was that different systems on the internet have different OS, browser, CPUs. So the same program was supposed to be compatible with different environments. 
		The same solution for security solves this problem.
		
		The java execution environment sovles the dependency issue.
	
	
	Bytecode :
		When we said that the security and portability was handled using the java execution environment we were talking about the JVM (java virtual machine).
		JVM is a part of java runtime environment which resides on the browser/client. 
		When the java code is compiled, the compiler does not convert it into native code or executable code directly. It converts it into Bytecode. Bytecode is highly optimized set of instruction to be executed by JVM.
		The original JVM is designed as an interpreter for the bytecode.
		This solves the security problem, because the JVM creates a restrictive execution environment called the sandbox, that contains the program which prevents any unrestricted access to the machine.
		
		For the portability issue, if JRE exists on the system then java program can run on it.
		
		SO IF SOMEONE ASKS IF WE NEED JDK OR JRE, WE NEED ONLY THE JRE TO RUN A PROGRAM, BECAUSE IT CONTAINS THE JVM.
		
		Coming back to the portability, since the program is now converted into a bytecode, which is interpreted by the JVM, the code on its own is independent of the OS, CPU, browser. However, the implementation of JVM will differ as per the underlying architecture.
		
		The issue with JVM was that it interprets the bytecode. This may look like performance bottle-neck, but it is not. The compiled bytecode is highly optimised. And on top of that, the HotSpot technology was introduced not long after java release. This hotSpot technology provides a just in time compiler(JIT compiler) for the bytecode.
		
		When a JIT compiler is part of the JVM, selected portion of the bytecode is compiled into execution code in real time, on a piece-by-piece, demand basis.
		The entire code is not compiled all at once, piece by piece. Also only that part of the code will be compiled which will benefit from compilation. Rest is interpreted. This just in time approach yields a significant boost.
		This dynamic compilation does not affect the portability and security because JVM is still in charge.
		
		There is one more specialized feature called as on ahead-of-time compilation, which compiles the code before execution by the JVM.
		
		In JDK 9, applets were deprecated
		and starting JDK 11, the support for applet was removed.
		
Web start :
	This was a deployment mechanism that allowed the application to be dynamically downloaded from the web page and start its execution. The difference in the web start and java applet was that the web start was not executed on the browser. Instead it ran as a stand alone program on the system. Hence it required a JRE installed on the system with web start support in it. JDK 11 removed its support.

Servlets :
	What are servlets?
		servlet is a small program that is executed on the server. Servlets are used to create dynamically generated data that is sent to the client.
		
		However, dynamically generated content is available through mechanism such as CGI (common gateway interface), but servlet offer several advantages like increased performance.
		
		What is common gateway interface(CGI)?
			Common gateway interface is a standard that facilitates the communication between the server and the database or the data source. It acts as a middleware, allowing web servers to interact with applications that process data and send back response.
			
		Advantages : 
			servlets are converted into bytecode and is executed on the JVM therefore, they are highly portable and secured.
		The only requirement for the servlet is that the server contains JVM and a servlet container.
		We will come back to this.
		
Java characteristics (BuzzWords): 
	What are the characteristics of java??
		simple : 
			Java is simple and easy to understand high level programming language. It inherits its features from c and c++ therefore programmers usually find it easy to understand.
		portable : 
			Java is portable because of the JVM which resides within the JRE. 
			Java code --compiler--> bytecode --JVM(interpreter/JIT compiler)--> native/executable code
		secure : 
			Java is secured because JVM have a full control over the execution environment of the code. So the environment can be restricted and any unauthorized access to the machine is prevented.
		high performace : 
			The bytecode which is generated from the source code using the compiler is highly optimised. Along with this JVM provides JIT as well which further increases the preformance.
		robust : 
			In programming robust means reliable. Java compilers can detect multiple flaws earlier that may show up at run time.
			Java does not support pointers therefore the issue of handling memory is avoided. It also provides exception handling to prevent run time exceptions.
		object oriented : 
			Java is object oriented which means the software design is around the data instead of functions and logic.
		architecture-neutral : 
			Java is independent of the underlying architecture i.e. the cpu and the OS.
		multithreaded : 
			Java supports multi threading. Meaning it supports execution of different part of the program to run simultaneously.
		interpreted : 
			Java compiler converts the source code to byte code using the compiler. This byte code is then converted into the native/executable code using the JVM interpreter. Now the JVM have both the interpreter and the JIT compiler. So a part of the byte code which will not gain advantage using the JIT compiler is interpreted.
		distributed : 
			Distributed computing involves the collaboration of multiple computers over a network. Java was created with the goal of making the distributed computing simple.
		dynamic : 
			The class files are loaded at runtime. java programs carry with them substantial amount of run time type information that is used to verify and resolve accesses to objects at run time.
jlink : 
	what is jlink??
		jlink is a tool which enables the programmer to create a run-time image of an application that contains only the necessary modules.
What is ubiquitous??	
	found everywhere, present, appearing
Spaghetti code :
	What is spaghetti code?
		It is a code which contains tangled jumps and conditional branches which makes the code virtually impossible to understand.
	
	
	
Object oriented programming (OOP) : 
	Types of paradigms : 
		There are two types of paradigms based on what the program is conceptually organised around. 
		Program can be organised around : 
			code
			data
		If the program is written around "what is happening" then it is process oriented.
		If the program is written around "what is getting affected" then it is object(data) oriented.
		
	C is procedural language. The issue with process oriented is that more the program grows in complexity, it gets more difficult to manage.
	Java and cpp are object oriented.
	
	
	abstraction : 
		Hiding the complexity of implementation from the user.
	Inheritance :
		inheritance is the process by which one object acquires the properties of another object.
	Encapsulation :
		encapsulation is the mechanism that binds together code and the data that it manipulates and keeps them safe from outside interference and misuse.
		Encapsulation is a programming technique that limits direct access to certain parts of an object. It's a key concept in object-oriented programming (OOP). 
		How it works
			Encapsulation hides data members and methods from other objects. 
			It restricts which users or functions can access certain information. 
			It makes data private, so it can only be accessed and modified through methods within the same class
	polymorphism :
		polymorphism is a feature that allows one interface to be used for a general class of action.
		this concept can be expressed by the phrase "one interface, multiple methods"

Identifiers :
	Identifiers are used to name things like classes, methods, variables.
	It can contain, alpha numeric characters, underscore and dollar.
	it cannot start with a number
	also they are case sensitive

whitespaces :
	java is a free form language so we can have all the program in a single line as long as the tokens are separated by white spaces.

literals :
	A constant value is called a literal.
	it can be : 
		1 or a or 1.1 or "this is a literal"

comments :
	There are three ways to give comments in java
	single line : //
	multi line : /* */
	documentation comment : /**   */

separators :
	what are all the separators :
		They are used to differentiate different region of block of code and arrange groups of codes or statements.
		
		() : used to contain the list of parameters in method. Also used to define precedence in expression
		{} : used to define local scope or a block of code. Also used to initialize array
		[] : used to define arrays and access the array elements
		; : used to terminate statements
		, : used to define variable identifiers, also used to chain statements together inside a for statement
		. : used to call instance variable or method
		:: : used to create a method or constructor reference
		... : variable length parameters
		@ : begins annotation
		
keywords : 	
	total number of keywords : 
		61 + 4 reserved(true, null, false and var i think)
datatypes :
	java have 2 types of datatypes :
		primitive and non primitive
	primitive datatypes : 
		primitive data types are also known as simple data types. They only hold a single value. Primitive types are not object oriented like non primitive.
		integer :
			This data type holds the whole numbers. In java all the integers are signed. There is no concept of unsigned integers in java. Java provides an operator called as the unsigned right shift operator which eleminates the need of unsigned int.
			To define integers in hexadecimal value, we need to use :
				0x1234567890abcdef
			To define integers in binary value, we need to use :
				0b1001
			While defining integers we can use the _ in the literals. This is ignored by the compiler. This is just for visual representation, like we add comma "," while writing number on a paper.
			int :
				it is a 4 byte that is 32 bits datatype. 
			byte :
				it is a 1 byte that is 8 bits datatype. When this type is used in an expression, it is automatically promoted to int.
			short :
				it is a 2 byte that is 16 bits datatype. When this type is used in an expression, it is automatically promoted to int.
			long :
				it is a 8 byte that is 64 bits datatype. To define if a literal is long we have to append the value with a "l" or "L".
		floating point : 
			This data type holds the real numbers. By default all the real numbers are converted into double. If we want to create float, we need to add "f" or "F" at the end of the number. Similarly if we want to define double explicitly then we need to append "d" or "D".
			float :
				it uses 32 bit that is 4 byte of storage. 
				this is used when we need to store a fractional value but higher precision is not required.
				the storage breakdown is as follows :
					1 bit for sign
					8 bits for exponent
					23 bits for mantisa
				it ranges from : 
					1.4e-45  to 3.4e+38
			double :
				it used 64 bit that is 8 bytes of storage
				this is used when we need fractional value with higher precision.
				the storage breakdown is as follows :
					1 bit for sign
					11 bit for exponent
					52 bit for mantisa
				it ranges from :
					4.9e-324 to 1.8e+308
		char :
			This datatype is used to store a single character.
			Java uses unicode to represent all the characters. 
			It is of size 2 bytes or 16 bits.
			there are no negative characters and the value of these char can vary from 0 to 65536.
			If we want to specify a character that is impossible to enter we add a "\" before the character.
		boolean :
			Boolean is a 1 bit datatype and can contain the value true of false.
			
	Non-primitive data types :
		arrays : 
		string :
		classes :
variables :
	A variable is a basic unit of storage. It is like a label given to a memory location that we want to use.
	A variable is defined by a combination of identifier, datatype and an optional initializing literal. In addition to these all the variables have a scope that define their lifetime and their visibility.
	All the varibles should be declared before using them.
	The variables can be initialized both statically meaning while declaring and dynamically while running.
	
	Variables can be declared in any block of code that is within any curly braces. The block defines the scope of the variable.
	Scope determines the visibility and lifetime of that variable.
	
	variables are created when the scope is entered and are destroyed when the scope is ended/left.
	
	we can define variable within the inner scope with the same name as the outer scope but in this case if the variable is class variable then we can use this.variableName to access that variable.


type conversion :
	If the variables are compatible then java will allow automatic type conversion. if the variables are not compatible then we need+ to type cast the variable(use a cast).
	automatic conversion/ implicit type casting :
		When the conversion of data type is done without an external cast metioned it is implicit or automatic type casting.
		it happens if one of the two conditions below is satisfied : 
			the two types are compatible
			the target type is larger than the given source type.
			
		The second condition is also called the widening conversion. In case of widening conversion for numerical types, incuding integer and floating point numbers are compatible with each other.
		There is no automatic conversion to char and boolean. 
		Similarly char and boolean are not automatically convertable.
		There is implicit conversion while storing integer literal while storing in byte, short, long and char.
		When we store in integer in the char variable, java implicitly converts it into a character based on the ascii value.
	
	explicit type casting : 
		When the variables are to be converted from a large source type to a small source type, then we need explicit type conversion. 
		This type of conversion is called narrowing conversion. 
		For explicit type conversion we need a cast : 
			(target-type) value
			
		There is one more type of conversion called the truncating. 
		Example of truncating conversion is float to int. Here the values after decimal is lost. 
		
		When we are converting from a larger type to a smaller type and the value is exceeding the range of the smaller type. Then the actual value is reduced by the following logic :
			newType var = (smaller type) some_value
			here the var will contain value = some_value % range of the smaller type.	
			Eg. :
				int x = 257;
				byte y = (byte) x;
				System.out.println(y)
				This will print 1 because 257 % 256
				byte is 8 bits. But its range is from -2^7 to 2^7 - 1. 
				So the reason we are taking 256 instead of 127 which is the range of byte, is because there are 8 bits. 
				So when 257 is written in binary that is with respect to bits,
					int will be like this : 0(sign) 0000000000000000000000100000001
					so when we convert it into byte it will be like :
					0(sign) 0000001
					Taking the last 8 bits 
					which is 1.
					
	Automatic type promotion :
		java automatically promotes the byte, short and char to int while evaluating the expression. This can cause confusing compile time errors. 
		for example :
			byte x = 1;
			x = x*2;  -> this will throw error because the operand were automatically promoted to int while the expression was being evaluated.
			this will throw the following error :
			error: incompatible types: possible lossy conversion from int to byte
			So internally, even though the variable is still byte, when it is as a part of evaluation, it is converted to int.
			Thus we cannot assign the value without the cast operator.
			that is why we call this as explicit type conversion because if the cast is not provided then the compiler throws error to confirm that this will be a lossy convertions
			
		type promotion rules : 
			1. all byte, short, and char are promoted to integer
			2. if one operand is long in the expression then all the operands will be automatically promoted.
			3. if one operand is float in the expression then all the operands will be promoted to float.
			4. if one operand is double in the expression then all the operands will be promoted to double.
			5. the promotion with int and float is float. So int + float will give float.
			
Arrays : 
	arrays are collection of elements with same datatype. Arrays can be of one dimension or of multiple dimensions.
	Arrays are stored in a continous memory location. And hence can be accessed using an offset.
	One dimensional arrays :
		declaration :
			type idenifier[];
		this declaration tells that this is an array but no array exist yet.
		
		initialization :
			identifier = new type(int/float/string/char)[size];
			
		if the datatype is ordinal i.e int, long, byte, short, float, char then gets initialized with 0.
		if the datatype is boolean it gets initialized with false.
		if the datatype is other than that it gets initialized with null.
		
		In java all the arrays are dynamically allocated.
		
		can also be defined like this : 
			type var[] = new type[size]
			
	Multi dimensional arrays : 
		in java multi dimensional arrays are declared as arrays of arrays.
		
		declaration :
			2D
			type var[][] = new type[rows][columns]
			
			type var[][] = new type[size][]
			var[0] = new type[new_size]
			
			
			3D
			type var[][][] = new type[size][size][size]
			
	we can also declare the array like this :
	
	type[] indentifier = new type[size];
	
String : 
	it is not primitive type.
	It is a class.
	declaration :
		String indentifier;
		

Operators :
	4 types of operators :
		arithmetic : 
			used in mathematical operations similar to algebra.
			The following are the arithmetic operators :
				+
				-
				++ (pre increment, post increment)
				-- (pre decrement, post decrement)
				%
				/
				*
				=
				/=
				+=
				-=
				*=
				%=
			cannot use these types on boolean but we can use them on char.
			when the division operator is attached to an integer there will be no fractional component attached to it.
		bitwise :
			these operators act upon individual bits of the operand.
			~ bitwise not
			&
			|
			^
			>> : right shift operator. Shifts the bits by given number of time to the right.
				2>>1 so right shift all the bits in 2 by 1 position.
				right shift retains the sign bit. Meaning that if a number is negative then the sign bit is set, when we shift it right, the new bit which comes in positon of old sign bit is also set. So we right shift more than the number of bits in the variable we get -1 because all the bits will be set.
			>>> : unsigned right shift operator. Shifts the bits by given number of time to the right, without preserving the sign bit.
				-2 >>> 99 so right shift all the bits in -2 by 99 positions.
				unsigned right shift does retain the old sign bit. Instead it replaces it with a 0. So after 100 shifts ideally all the types will contain 0.
			<< : left shift operator. Shifts the bits by given number of time to the left.
				New bit will contain 0. And the left most bit is lost.
			^=
			|=
			&=
			>>=
			>>>=
			<<=
			
			Note :
				automatic type promotion give unexpected result when shifting operators left or right. Because when the byte and short are shifted, java first converts them into int and then perform the shift operation this can cause unexpected results.
		boolean logical :
			these operators operate only on boolean operands.
			&
			|
			^
			&&
			||
			!
			&=
			|=
			^=
			!=
			==
			? : ternary operator
		relational :
			these operators are used to determine the relationship between operands.
			==
			<
			>
			!=
			>=
			<=
			The outcome of these operators is always boolean.
	
	Operator precedence : 
		precedence from highest to lowest (same priority if on same line):
			++(postfix) --(postfix)
			++(prefix) --(prefix) ~ ! +(unary) -(unary) (type cast)
			* / %
			+ -
			>> << >>>
			> >= < <= instanceOf
			== !=
			&
			^
			|
			&&
			||
			? :
			->
			= op=
			
	instanceOf operator: 
	
	-> (lambda) operator:
	
	
Control statements :
	there are 3 kinds on control statements :
	selection statement :
		the statement which allows selection of a particular flow in a program
		if statement 
		switch statement :
			we can write switch within a switch 
			switch statement only work on 
			int, byte, short, char, or enumeration and string.
			break statement exits the switch block
	iteration statement :
		statements which cause a certion code to repeat its execution
		for(initialization(can contain comma separated values); condition(can contain comma separated values); interation(can contain comma separated values)) {}
		while (condition) {}
		do{ } while(condition);
		for-each : for(type var : list) {}
		
		we can use a local variable type inference in both the traditional and for-each loop.
	jump :
		statements which allows program to execute in a non linear fashion. Meaning jumping from one part to another
		java supports 3 jump statements :
			break :
				exit switch
				exit loop
				using break as a form of Goto :
					labelled break statement :
						this is equivalent of a goto statement. 
						We can use this statement to exit any block of code not just the loop or switch statement. And not just exit the block it can specify where to resume its execution as well.
						The general form of labelled break statement is as follows :
							break label;   -> label is a name of label that identifies a block of code.
							when this form of break executes, the control is transfered out of the named block.
						
						the break should be within the block, but this doesnt mean that the block should be the immediate enclosing block.
						so basically we can escape a nested block but we cannot escape a block for which the break is not a part of.
						lable: {
							{
								break lable; ->  this will work and break out of the blocks
							}
						}
						
						but the below will not work :
						lable: {
							{
							}
						}
						break lable; -> because it is not a part of that block.
						
					To name a block we need to add a label in front of it.
					We can use this label to target the transfer from that block. When the break is used with this label, the control will jump to the end of that labelled block.
					
					l1: {
						break l1; -> this will transfer us to the end of this block.
					}
					
					first: {
						second: {
							third: {
								break second; -> this will get us out of second block completely skipping rest of third and second block.
							}
						}
					}
			continue : 
				used to force an early iteration of the loop. 
				Uses to skip the rest of the execution and continue with the next iteration. 
				In for loop, the control is transfered to the iteration(increment/decrement) and then to the condition. 
				In while and do-while, the control is transfered to the condition directly.
				
				Just like the break, we can use a label with continue to stop the current loop's execution and skip to some different iteration of some parent loop up the hierarchy.
				eg. 
					first : for() {
						for() {
							continue first; -> this will terminate the inner loop and will jump to the next iteration of parent loop.
						}
					}
				
			return :
				It is used to immediately terminate the current execution of the method and transfer the control back to the caller method. 
				In case of main method, the control is returned to run-time system, because run-time system calls the main method.
				If return is not the last statment in a method and return is not conditional, then the compiler throws an exception stating that there is an unreachable code in the program.
		exception handling is also used for jumping.
		
label :
	a label is any valid identifier with a colon in front of it.
	we can give a label to a for loop as well :
		loop1: for(int i = 0; i < n; i ++) {
			loop2: for(int j = 0; j < n; j++) {
				break loop1; -> this will break both the loops.
			}
		}
		
		
Java virtual machine :
	JVM is the heart of java program execution. It is a part of java runtime environment(JRE). JVM acts as a run-time engine to run java application. It is the one that actually calls the main method present in a java code. JVM is the reason that java is platform independent.
	Java compiler converts the java program into byte-code i.e. .class file. This byte-code is taken for further execution by the jvm.
	Architecture :
		class loader subsystem :
			This loads the .class file in the memory.
			Then it verifies if the byte code instructions are proper or not if not it will terminate the execution.
			if the byte code instructions are proper, it will allocate necessary amount of memory to execute the program.
			class loader does three things :
				loading :
					for each .class file, jvm stores the following information in the method area.
				linking :
					this performs :
						verification :
							It ensures the correctness of the .class file. It checks whethere this file is properly generated by the compiler. If the verification fails, we get run time exception stating java.lang.verifyError. ByteCodeVerfier is the component that verfies the bytecode.
						perparation :
							allocates the memory for class static variables and initialize the values of default variables.
						resolution(optional) :
							it is the process of replacing the symbolic references from the type with direct references. It is done by searching into the method area to locate the referenced entity.
				initialization :
					In this phase, all the static variables are assigned with their values defined in the code and static block. This is executed from top to bottom in a class and from parent to child in the class hierarchy.
			there are three class loaders :
				bootstrap class loader : Every jvm implementation should hava a boostrap class loader, capable of loading trusted classes. It loads core java api classes present in the JAVA_HOME/jre/lib directory. This is known as the bootstrap path. It is implemented in the native languages like c/c++
				extension class loader : It is a child fo the boostrap class loader. It loads the classes present in the extension directories or any other directory specified  by the java.ext.dirs system properties.
				System/application class loader : it is a child of the extension class loader. It is responsible to load classes from the application classpath.
				
				JVM follows delegation-hierarchy principle to load classes. System class loader delegate load request to extension class loader. Extension class loader delegates instruction to bootstrap class loader. If a class found in the boot-strap path, the class is loaded otherwise a request is made to the extension class loader if class is found, it is loaded else another request is made to the system class loader. If the system class loader fails to find the class, then we get run-time exception java.lang.classNotFoundException.
		
		JVM memory/runtime data area :
			heap :
				This is the place where all the objects, object information and instance variables are stored. There is only one heap area per JVM. It is also a shared resource.
			java stack area/JVM language stacks: 
				For every thread, JVM creates one run-time stack which is stored here. Every block of this stack is called acitvation record/stack frame which stores method calls. This stack frame will contain all the information related to that method and the local variables of that method.
				When the thread terminates, its run time stack gets destroyed as well by the JVM. It is not a shared resource(run time stack).
			native method stack :
				For every thread, a separate native method stack is created. It stores the native method information.
			program counter register (PC register) :
				Stores address of current execution instruction of a thread. Each thread has separate PC register.
			method area : 
				This includes all class level information like name, immediate parent class name, methods and variable information including static variables. There is only one method area per JVM, so this is a shared resource.
		
		execution engine :
			It reads the bytecode line by line, uses data and various information present in the JVM memory/runtime data area and executes the instructions.
			JIT compiler :
				It is used to increase the efficiency of the interpreter. It compiles the code which can take advantage of compilation and executes it.
			Interpreter : 
				It interprets the byte code line by line and executes it. The disadvantage here is that if a method is getting executed in loop, it reads it line by line everytime(everytime interpretation is required).
			garbage collector :
				It destroys un-referenced objects.
				This is the process by which java programs perform automatic memory management.
				When the program runs on jvm, the objects are created on heap, which is a portion of memory dedicated to the program. The garbage collector finds unused objects on the heap and deletes them to free up memory.
				Main objective is to free heap memory by destroying unreachable objects.
				The garbage collector is the best example of Daemon thread because it is always running in the background.
				
				In-use object or referenced oject is the object that is still in use in the program meaning a pointer to this object is still maintained.
				Unused object or un-referenced object is the object that is not in use and there is no pointer in the program pointing to this object.
				
				The garbage collection implementation lives in the JVM.
				
				Types of activities in java garbage collection :
					The two types of collection activites that happen in java are :
						What is old generation and young generation garbage collection :
							The heap is divided into two sections : 
								young generation(where new objects are generated)
								old generation(objects are moved here from young generation)
							Young generation heap contains all the initial objects that are created on start up. 
							The garbage collector iterates through all the objects and mark them if they are in use and in the next iteration it deletes all the unmarked objects. This is one cycle of garbage collection.
							So if an object survives couple of garbage collection cycle, then the object from the young generation heap is transfered to old generation.
							The idea is that most application objects are short lived and therefore will be destroyed frequently using the young generation heap.
							The old generation heap will contain objects which need not be deleted frequently.
						minor or incremental garbage collection :
							It is said to have occured when the garbage collection is done in young generation heap. This is done more frequently.
						major or full garbage collection :
							It is said to have occured when the object from old generation of permanent generation is removed. This is done less frequently.
				
				Ways to make an object unreachable(eligible for garbage collection) :
					1. nullifying the reference variable
					2. re assigning the reference variable
					3. an object created inside the method
					4. island of isolation(group of object that reference each other but not referenced by any active object in the application. A single unreferenced object is also an island of isolation)
				
				
				How to request JVM to run garbage collector :
					1. using System.gc()
					2. using Runtime.getRuntime().gc()
					There is no guarantee that any of the above method will run garbage collector.
					the call System.gc() is equivalent to the call Runtime.getRuntime().gc()
					
				Just before destroying an object the GC calls the finalize() to perform cleanup activities. We can override this method to provide a custom cleanup activity. finalize() method is called by GC not the JVM. The default implementation of finalize() is empty(no actions).
				if there is an exception in finalize() method the finalization terminates but the exception is ignored as well and the object will be destroyed.
				Garbage collector is one of the modules of JVM.
				
				Advantages :
					it is automatic process and we need not provide extra efforts
					it makes java memory-efficient because it frees up un-referenced memory. 
		native method interface :
			It is an interface that interacts with the native method libraries and provides the native libraries required for the execution. It enables jvm to call c/c++ libraries.
		
		native method libraries :
			It is a collection of native libraries which are required by the execution engine.
		
classes :
	The class forms the basis of object-oriented programming in java.
	It defines the shape and nature of the object.
	Any concept which we want to implement in java must be encapsulated in the class.
	Class defines a custom new data type. Once defined we can use this new datatype to define objects. 
	Class is a template for an object. Object is an instance of a class.
	The method or the code defined in the class provides the interface to its data.
	
	Syntax :
		class identifier {}
		
	the data/variables can be defined within the class called as instance variables.
	the code is written inside the method.
	collectively the method and the instance variables are the members of the class.
	Generally the variables can be accessed through the methods of the class. Therefore, the methods determine how the class variables are used.
	Instance variables are called instance because each object/instance have its own copy. Meaning that each object will have its unique instance variable independent of another object.
	
	Only that class have a main method which is the starting point of the application.
	
	Object creation syntax :
		type identifier = new type();
		This statement creates an object and brings reality to the class. The class declaration on its own does not bring the class to reality. Its just a template of what that datatype can do. Creating object actually allocates memory and gives it its own existance.
		
		type identifier; -> declares reference variable
		identifier = new type(); -> allocates the reference to identifier.(identifier will just hold the memory address to the object)
		
	NOTE :
		WHEN WE WRITE A FILE WITH TWO CLASSES THE COMPILER WILL CREATE TWO SEPARATE .CLASS FILES ONE FOR EACH CLASS. 
		
	All class objects must be dynamically allocated.
	
	Java primitive types are not implemented like objects. Therefore, we don't need new while defining primitive types like int, char, float, etc.
	
	Class is a logical construct, object has physical reality.
	
	When one reference variable is assigned to another reference variable, it does not create a separate object in the memory, the same reference is assigned to the new reference variable. So any changes to the new variable will be reflected for the old reference variable as well because the object is the same.
	
	methods :
		
		syntax :
			return_type identifier(type param(optional)...) {}
			
			return_type can be either void or any other valid datatype including new classes defined by the user.
			
		methods define the interfaces to most of the classes. This hides the specific layout of internal data behind cleaner method abstraction.
		In addition to methods which give access to data, internal methods that are used by classes are also there.
		
new keyword :
	The new operator dynamically (at run time)allocates memory for the object and returns its reference.
	
constructors :
	The constructor defines what occurs when an object of that class is created.
	If we dont define a constructor, then java provides a default constructor.
	constructor do not have a return type. This is because the implicit return type of a class's constructor is the class type itself.
	It is constructor's job to initialize the internal state of an object.
	If we do not define a constructor in the class, then java provides a default constructor.
	For default constructor all the instance variables will be given their default initialization values of 0, null and false for numeric, reference and boolean instances.
	when we define our own constructor, the default constructor by java is no longer used.
	
	parameterized constructors :
		constructor with parameters is called parameterized constructor.
		
this keyword:
		It is similar to self in python.
		'this' refers to the calling object, which is the object that called the method, on which the method was called.
		'this' stores the reference of the object that is created. With this we can say that it is literally the copy of 'self' which we learned about in python.
		Also 'this' have a local scope.
		
		This refers to the object on which the method was invoked.

instance variable hiding :
	It is illegal to have two variables with the same name in a same scope as per java.
	But we can have local variables which include formal parameters with the same name as that of the instance variable. 
	In this case the local variables hide the instance variables.
	Because this keyword allows us to access the object variable, we can use it to resolve any namespace collision that might occur between instance variables and local variables.
	Therefore, we can use this keyword to overcome instance variable hiding.
	
	
important points: 
	1. both method parameters and local variables can be final.
	2. we can initialize final variables in constructor or while declaring them.
	3. method can also be final
	4. arrays are implmeneted as objects therefore, we can make use of length instance variable.
	5. the scope of the nested class is bounded by the scope of the enclosing class. So if B is in A then B cannot exist without A.
	6. nested class has access to the member of its parent class including private members and vice versa enclosing class does not have access to the members of the private class.
	7. nested class can also be inside a block which makes it local to that block. Meaning that inner class can be defined within the body of a for loop as well.
	8. there are two types of nested classes : 
		static 
		non-static
	9. Inner class is a non-static nested class.
	10. a class can be static if it is nested. We cannot make an outer class static. We might need inner class to be static to remove the dependency of instance of outer class. 
	One example for the use case of this is :
		implementing builder pattern for an immutable class.
		class car {
			String name; 
			String model;
			
			public car(CarBuilder carBuilder) {
				this.name = carBuilder.name;
				this.model = carBuilder.model;
			}
			
			public static class CarBuilder {
				String name;
				String model;
				
				public CarBuilder setName(String name) {
					this.name = name;
					return this;
				}
				public CarBuilder setModel(String model) {
					this.model = model;
					return this;
				}
				
				public CarBuilder build() {
					return new Car(this);
				}
			}
		}
		in another class : 
		public static void main(String arg[]) {
			Car car = Car.CarBuilder().setName().setModel().build();
		}
	11. inner class has access to all the variables and methods of the outer class and can access them directly
	12. generally speaking the instance of inner class can only be created in context of outer class and is created within the enclosing code. But we can create an instance of the inner class outside the enclosing class as well.
		OuterClass outerObject = new OuterClass();
		OuterClass.InnerClass innerObject = outerObject.new InnerClass()
	13. string object is immutable but stringBuffer or stringBuilder are mutable.
	14. string methods : 
		equals()
		length()
		charAt()
	15. variable length arguments are written like this :
		void method(int ...v)
		... followed by variable name.
		This means that v will have 0 or more arguments
	16. we can access the elements of variable length arguments similar to arrays.
	17. varargs can be used with normal parameters, but in that case, the varargs should be the last parameter.
	18. there must be only one variable length argument in a method. More than one vararg will throw error
	19. we can overload varargs methods as well, changing the vararg datatype, adding normal parameters with varargs.
	20. We can overload the varargs method with a non-varargs method as well, in that case, if vaTest(int a), vaTest(int ...a) are both present, then if based on the number of parameters sent to the method, either will be called, for 1 argument, first method will be called and for 2 or more arguments, second method will be called.
	21. ambiguous call in varargs :
		in case we have two overloaded methods :
			vaTest(int ...a)
			vaTest(boolean ...a)
		and then there is a call to the method : 
			vaTest();
		This will throw error, stating ambiguous call because both the boolean and int methods are a valid candidate.
		
		in case we have two overloaded methods : 
			vaTest(int a, int ...b)
			vaTest(int ...b)
		This is also ambiguous for the following call :
			vaTest(1);
	22. local variable type inference works with user defined datatypes as well.
	23. for inheritance : 
		class subclass-name extends superclass-name {}
	24. we cannot inherit or extend more than one class in java. Java does not support multiple inheritance.
	25. multi-level inheritance is allowed.
	26. class cannot extend itself, cannot inherit itself.
	27. a parent class reference variable can hold a reference to an object of type subclass.
	28. Important point to remember, it is the type of the reference variable and not the type of the object that it refers to that determines which all members can be accessed. Therefore, when a parent reference var holds a child object, it can only access the parent members of that object not the child object.
	29. super : 
		NOTE : If there is no default constructor specified in the parent class, then in the child class constructor we need to call the super() as a first line to be executed.
		1. used to access the constructor of parent class : 
			super(argument list)
			This statement needs to be the first statement in the subclass constructor.
			This is to prevent the subclass part of the object being initialized prior to the superclass part of the object.
		2. access the members of the superclass that has been hidden by the members of the subclass. : 
			This is similar to the use of this. Here instead of current class, super refers to immediate parent class.
			super.member 
			the member can be method or instance variable.
			This form of super is most applicable to situations in which member names of a subclass hide members by the same name in the superclass.
			i.e both the classes have a variable b.
	30. super() refers to the superclass immediately above the calling subclass
	31. order of constructor execution : 
		the order is from superclass to subclass
		basically the class hierarchy, constructors complete their execution in order of derivation, from superclasss to subclass.
	32. if the super is not called in the constructor of a subclass, in that case, the default or parameter less constructor will be executed.
	33. therefore, if the class hierarchy is as follows : 
		a -> b -> c 
		then the constructors will be called like this : 
		inside a
		inside b
		inside c
		This makes sense because super class is unaware of the existence of subclass, therefore, its execution must be completed first.
	34. when the method in the parent class has the same name and type signature as the method in the child class it is called as method overriding.
	35. dynamic method dispatch is the mechanism by which a call to an overridden method is resolved at run time. Dynamic method dispatch is how java implements run-time polymorphism
	36. It is the type of the object being referred to that determines which version of an overridden method will be executed.
	37. So for the following case : 
		A -> B (B is subclass of A)
		A -> C (C is subclass of A)
		then :
		A a = new A();
		B b = new B();
		C c = new C();
		
		A r; 
		r = a;
		r.x() -> calls a's method 
		
		r = b;
		r.x() -> calls b's method
		
		r = c;
		r.x() -> calls c's method
		
		Basically it is the object that will determine which method to call and not the reference variable.
	38. why overridden methods ?
		way for java to support run time polymorphism. It allows a general class to specify method that will be common to all its derivatives, while allowing subclasses to define its own specific implementation. : 
		one interface many methods
	39. superclass and subclass forms a hierarchy that moves from lesser to greater specialization.
	40. abstract class :
		we use abstract class in the scenario where the superclass does not have a meaningful implementation of a method and it is upto the subclass to implement it.
	41. To make sure that a subclass implements a method from the super class java have abstract methods : 
		to declare a method as abstract we need to use the following format : 
			abstract type methodName(paramList); -> no method body
	42. Classes with abstract methods must also be defined as abstract : 
		the way we define an abstract class is by adding abstract keyword before the class keyword : 
			abstract class className {}
	43. we cannot instantiate abstract classes because it does not make sense as there are no complete implementations of methods.
	44. cannot declare abstract constructors or abstract factory methods.
	45. if a class is abstract and a subclass extend it, it must define all the abstract methods or should be declared as abstract itself.
	46. we can have concrete methods in abstract classes.
	47. an abstract class can have zero abstract method
	48. There are three uses of final keyword : 
		1. to prevent the user from changing the value of a variable or in other words create a constant with a name
		2. declaring a method as final. Declaring the method as final prevents it from getting overridden. So to prevent a method from getting overridden, we need to declare the method as final. Overriding a final method throws a compile time error. There is a possibility of performance enhancement because the compiler is free to add the bytecode for the subroutine directly thus eliminating the overhead associated with method call.
		This is called as early binding
		syntax : 
			final returnType methodName() {}
		3. using final to prevent inheritance. If we declare a class as final, all of its methods are declared as final implicitly.
		A final class cannot be inherited.
		A class cannot be abstract and final at the same time.
		final class className {}
	49. local variable type inference with inheritance : 
		The local variable type inference infers the variable based on the initializer. Therefore, the type of the variable is based on initializer.
		So if we have a method called as builder of type myClass
		and it is returning the subclass objects,
		since the method return type is myClass, and even though the actual object is of type subclass,
		the inferred type will be myClass.
		and therefore, we wont be able to access the subclass properties, because according to java it is of type myClass and not subclass.
		refer to page number 331 if not clear.
	50. Object is the super class of all the classes in java. Therefore, a reference variable of type object can refer to any object.
	Since arrays are implemented as classes, a variable of type object can also refer to any array.
	51. Object have some methods defined as well, which means that these methods are available in every object. These methods are as follows :
		Object clone()
		boolean equals(Object object)
		void finalize() -> called before an unused object is recycled (deprecated)
		Class<?> getClass() -> gets the class of an object at runtime.
		int hashCode() -> returns the hashcode associated with the object
		void notify() -> resumes execution of a thread.
		void notifyAll() -> resumes execution of all the threads.
		String toString() -> returns the string that describes the object
		void wait(zeroParam/long milsec/long milsec, int nanosec) -> waits on another thread of execution
		
	the following methods from above are described as final : 
		notify()
		notifyAll()
		getClass()
		wait()
	toString() is automatically called when we try to output the object in println()
	52. packages are containers for classes.
	It allows us to create a compartamentalized name space. Therefore, we can have a list of classes in a package and dont have to worry about the name colliding with another class of another list. 
	Therefore, 
	packageA -> classA 
	packageB -> classB
	So what packages do is partition the class names into more manageable chunks. 
	package is both the naming and visibility control mechanism
	Using packages we can have classes or class members which are not accessible outside the package.
	
	Defining package : 
		package packageName;
		This statement defines the namespace in which the classes are stored
	We need to add this statement as the first line in the source code.
	Any classes defined in this file will be under the given package name.
	If there is no package name defined, the classes are put into default package which has no name
	typically java uses file system directories to store packages
	We can have hierarchy of packages. To have a multi level package system, we can use period : 
		package package1[.package2[.package3]];
		
	The package hierarchy must be reflected in file system :
		package a.b.c;
		needs to be stored as 
		a/b/c in file system.
	53. how can java find the package??
		in order for a program to find mypackage, there are three ways : 
			1. execute the program from a directory immediately above mypackage
			2. CLASSPATH must be set to include the path to mypackage.
			3. -classpath option must specify the path to mypackage when the program is run via java
		
		for example refer to page no. 337
		To use the class from another package using the dot operator may be tedious because the format is something like this : 
			class a extends package1.b {}
		So for this we have import statement.
		Using import statment, we can import classes or entire packages and then we just need to use the class name.
		import statment is convenience and not technically needed.
		
		import statement : 
			written directly after the package statement and before the class definition.
			syntax : 
				import package1[.pkg2].(className|*);
		
		NOTE : 
			java.lang PACKAGE IS IMPLICITLY IMPORTED BY THE COMPILER FOR ALL PROGRAMS.
			
		NOTE : 
			IF THE NAME OF THE CLASS IS SAME IN TWO DIFFERENT PACKAGES AND WE IMPORT BOTH USING THE *, IN THAT CASE, THE COMPILER WILL REMAIN SILENT AS LONG AS WE ARE NOT USING THE CLASS. ONCE WE HAVE USED THE CLASS IT WILL THROW A COMPILE TIME ERROR AND WE HAVE TO EXPLICITLY NAME THE CLASS SPECIFYING ITS PACKAGE.
			
			SO The FOLLOWING EXAMPLES ARE SAME :
				import java.util.*;
				class MyDate extends Date {}
					AND 
				
				class MyDate extends java.util.Date {}
				
	54. java addresses four categories of visibility for class members : 
		1. subclass (childclass) in the same package
		2. non-subclass in the same package
		3. subclasses (childclass) in different packages
		4. classes that are neither in the same package nor subclasses.
		
	for the table refer to page number : 339
	
	members access : 
		1. anything declared as public, is accessible from different classes and different packages
		2. anything declared as private, is only accessible within its own class
		3. anything declared as default, is accessible from subclasses and other classes within the same package and not accessible from other package, even the subclass from another package cannot access default.
		4. anything declared as protected, can be accessed anywhere within the same package, outside the package it can only be accessed by the subclass that is the child class.
	non nested classes can either be public or default.
		1. default classes can be accessed only within the same package
		2. public classes can be accessed outside the package. 
		NOTE : IF A CLASS IS DECLARED AS PUBLIC IT MUST BE THE ONLY PUBLIC CLASS IN THAT FILE AND IT'S NAME SHOULD BE THE SAME AS THAT OF FILE.
	55. Interfaces : 
		Using interface, we can specify a set of methods that can be implemented by one or more classes.
		Interfaces define what a class must do but not how it does it.
		In traditional form, interfaces does not define any implementation.
		A class can implement more than one interfaces. Unlike abstract and normal classes where we can only extend one class.
		If we are extending a class from another package and we have not written the import statement, in that case, we can write extend the class some thing like this : 
			class protection2 extends p1.protection {}
			for more details read the example on page number 342.
	56. A class implementing an interface need to implement all the methods in that interface. 
	57. using the interface keyword java allows us to fully utilize the "one interface, multiple methods" aspect of polymorphism.
	58. defining an interface :
		accessSpecifier interface interfaceName {} 
		1. if the accessSpecifier is absent, then it results in default access, meaning interface is only available within the package.
		2. if the accessSpecifier is public, the interface can be used outside the package. But in this case, it must be the only public interface in that file and the name of the file and the interface name should be same.
	59. The interface can only have abstract methods and no concrete methods. Remember, that the methods declared in interfaces are implicitly abstract, therefore, no need to add the abstract keyword. 
	NOTE : PRIOR TO JDK 8, INTERFACES ONLY HAD ABSTRACT METHODS. FROM JDK 8, INTERFACES CAN HAVE DEFAULT IMPLEMENTATION TO AN INTERFACE METHOD. ALSO IT CAN HAVE STATIC INTERFACE METHODS.
	FROM JDK 9, AN INTERFACE CAN INCLUDE PRIVATE METHODS.
	NOTE : ALL THE METHODS ARE IMPLICITLY PUBLIC
	60. Attributes/variables in an interface are implicitly final and static meaning they cannot be changed by implementing classes and they must also be initialized.
	NOTE : ALL THE VARIABLES ARE IMPLICITLY PUBLIC.
	
	61. syntax of implementing an interface :
		class classname [extends superclass] [implements interface1, interface2, ...]
	
	62. The method that the subclass implements for an interface must have public access specifier.
	
	63. Similar to using a superClass variable to call a subClass object, we can use a reference variable of type interface to store an object of a class that implements that interface.
	The method being called is determined at runtime based on the instance variable.
	Since the reference variable in the above case is of type interface, it can only access the methods and variables that are declared in the interface and the variable have no information about other attributes of the subClass similar to superclasses.
	
	64. A class which does not implement all the methods of the interface being implemented must be declared as abstract.
	And as a result the class inheriting this class should either implement the method or should be declared as abstract itself.
	
	65. An interface can be declared as a member of a class or another interface. This is called as nested interfaces.
	This nested interface can be private, protected or public
	When this interface is used outside the parent class or interface, it must be qualified by the name of the parent class or interface. Its name should be fully qualified.
	Example : 
		class A {
			public interface i1 {
				returnType methodName();
			}
		}
		
		class B implements A.i1 {}
		
	If we want to create a reference variable using the interface, we need to use  : 
		A.i1 variableName = new B();
		
	66. Interfaces can be extended. Meaning an interface can inherit another interface by using the "extends" keyword.
	eg.
		interface interfaceName extends interfaceName2 {}
	
	In this case, the class implementing the child interface needs to implement all the methods required by the interface inheritance chain.
	
	67. From JDK 8 we can have default methods in interfaces, which have some default implementations.
	NOTE : DEFAULT METHODS ARE ALSO SOMETIMES REFERRED TO AS EXTENSION METHODS.
	
	68. The use of default method was to prevent the breaking of existing code if a new method is added to an interface which is not implemented by the existing code. 
	The default behaviour is used if no implementation is provided.
	Another motivation for default methods was to provide optional methods in interfaces.
	
	69. Even with the default implementation, we cannot create an instance of the interface.
	
	70. default methods : 
		default methods can only be used inside an interface. Cannot be defined within an abstract class.
		Default methods are similar to normal class methods, only thing that is changed is the default keyword in front of the method
		eg : 
			default returnType functionName() { 
				default implementations.
			}
		So the generalized form of default method is add "default" before method declaration
	
	71. So if no implementation for the default method is found in the implementing class, it will use the default implementation
	
	72. A class can hold state information especially with the use of instance variable but interface cannot.
	
	73. to handle ambiguous situations while implementing multiple interfaces with default methods, we have following rules : 
		1. class implementation take priority over an interface default implementation
		2. if class is not implementing the method and there are two interfaces with default methods implemented with the same name, in that case an error will be thrown, 
			class a implements b,c {}
			b and c have method named as method1(); -> this will throw an error.
		3. if an interface is extending another interface and both are providing a default method with the same name and there is no implementation provided, in that case the interface that is extending that is the child interface's version of default method is used
	
	74. InterfaceName.super.methodName() this is the way child interface can refer to parent interfaces default method.
	
	75. Another capability added by JDK 8 is to define one or more static methods.
	Similar to class static methods, interface static methods can be called independently of any object
	THEREFORE, NO IMPLEMENTATION OF AN INTERFACE AND NO OBJECT ON AN INTERFACE IS REQUIRED TO CALL THIS METHOD
	eg. 
		InterfaceName.methodName()
	
	76. IMPORTANT POINT : 
		STATIC METHODS ARE NOT INHERITED BY EITHER AN IMPLEMENTING CLASS OR A CHILD-INTERFACE(SUB-INTERFACE)
	
	77. private interface methods : 
		from JDK 9, an interface can include private methods.
		This method can only be used by methods which are default or are private.
		Since these methods are private, they cannot be accessed by other interfaces or implementing classes.
	
	78. The advantage of private method is that it lets the default methods use common code avoiding code duplications.
	for example refer to page number 371
	
	79. exceptions can be generated by our code or by the java run time system
	
	80. for exception handling we have five keywords : 
		try : 
			contains code that may throw an error/exception.
		catch :
			code handling the exception is written here
		throw :
			to manually throw an exception we use the throw keyword
		throws :
			This specifies an exception that will be thrown by the method.
		finally :
			This block contains code that needs to be executed irrespective of an exception being thrown or not.
	
	81. There is one more form of try statement called as try-with-resources.
	
	82. All the exceptions are subclass of built-in class Throwable.
	
	83. Throwable have two sub classes :
		Error class implies a problem that mostly arises due to the shortage of system resources and exceptions occur during runtime and compile time
		1. Exception
		2. Error : 
			Exceptions of this type that is error are used by java run time systems to indicate errors having to do with run time environment itself
			eg :
				stackOverflow
			
			Errors are typically created in response to catastrophic failures that cannot usually be handled by program
	
	84. If an exception is not caught by a handler in our program, the default handler provided by java run time system will handle it. 
	The default handler prints a string describing that exception, prints the stack trace from the point of exception and terminates the program
	
	85. the exception stack trace contains the method calls in sequence of the exception occured.
		eg.
			at class.subroutine()
			at class.main()
		here main is calling subroutine
		and subroutine has the exception
	
	86. A try block can exist without : 
		finally block 
		catch block
	We can have multiple catch clauses. The first match of the exception catch block will be executed.
	
	87. Throwable overrides the toString() method, so that it returns a string. Therefore, we can pass the exception object to the println method to display the exception.
	
	88. All the super classes in exception handling should be at the end of the catch chain. 
	NOTE : IN JAVA AN UNREACHABLE CODE IS AN ERROR. SO IF WE HAVE AN UNREACHABLE CODE, THE COMPILER WILL THROW AN ERROR.
	
	89. We can have nested try statements in java. So a try statement can have a try within it.
	If an exception occurs in the nested try block, all of its catch statements are checked. If there is no match, outer try blocks catch statements are checked. If matched, it will handle, else it will look for outer one.
	If there is no match, java run time system will handle it using default catch and will terminate the program.
	The nesting of try can occur because of method calls as well, if a method call within a try block contains a try block then it also nesting of try.
	
	90. If we want to throw an exception explicitly, then we use the throw statment :
		eg  :
			throw ThrowablInstance;
	Primitive types like int, char or non-throwable classes like string and Object cannot be used in throw statement.
	We can create a Throwable object using parameter in the catch clause or using a new operator.
	
	91. Throwable has a method defined in it called as the getMessage() method that can be used to get the description message of the exception.
	
	92. Throws : 
		This keyword specifies the list of all the exceptions that a method can throw.
		We need to specify these exceptions so that the calling code can guard it self against these exceptions.
		Syntax : 
			type methodName() throws exception1, exception2 {}
		NOTE : 
			IF THERE IS A THROW STATEMENT IN THE METHOD THAT IT IS NOT HANDLING, MEANING THAT THE METHOD MIGHT PRODUCE AN EXCEPTION THAT IT IS NOT HANDLING AND WE ARE NOT DEFINING THIS IN THE THROWS CLAUSE, IN THAT CASE WE WILL GET A COMPILE TIME EXCEPTION.
			
	93. If we are calling a method which has a throws clause, then we need to call that method in a try catch block or we need update the calling method definition stating that it might also throw that exception.
	Basically the parent method needs to define a throws clause as well stating it is not handling that exception just rethrowing it.
	
	94. finally clause is used to execute statements that we need to execute irrespective of the exception occuring or not.
	This block will be executed in all the scenarios :
		1. if there is no exception and a return statment is called, finally block will be executed.
		2. if there is no exception and no return statment, still finally block iwll be executed.
		3. if there is an exception and a catch block is present, still finally will be executed after catch.
		4. if there is an exception and no catch is present, still finally will be executed.
	
	95. RuntimeException : 
		These are unchecked exceptions and therefore, compiler does not check for them. Therefore, these exceptions need not be included in any method's throws list.
		
	95. Unchecked exceptions need not be defined in throws clause, however, checked exceptions need to be listed or defined in the throws clause of a method.
	pageNo.395 or table 10.1 gives unchecked exceptions.
	pageN0.396 or table 10.2 gives checked exceptions.
	
	97. Custom exception classes : 
		create a subclass of exception (which is a subclass of Throwable)
		
		We do not need to implement anything. Exception class does not define any method. Throwable class do that Exception inherits.
		We can override these methods as and when required.
		Some common methods of Throwable class are : 
			toString()
			getMessage()
			getStackTrace()
		For more info on methods : pageNo. 397, table 10.3
		
	98. there is another form of exception called as chained exception. Here there is an underlying exception that caused the current exception.
	So while creating that exception we can set the underlying exception using either the constructor of the form : 
		Throwable(Throwable causeExc);
	or using the initCause(Throwable causeExc) method available in Throwable class.
	If we use constructor we cannot use the initCause() method and initCause() method can only be used once.
	We also have a getCause() method which can be used to get the underlying exception.
	
	99. Multi-catch feature : 
		Same catch clause allows two or more exceptions to be caught.
		syntax : 
			catch(ExceptionClass1 | ExceptionClass2 variableName) {}
		
		precise rethrow : 
			we need to declare the variables as final.
	
	100. Mutli-threaded program have multiple threads where each part of the program have different path of execution and is getting executed concurrently.
	Multi-threading is a specialized form of multi-tasking.
	
	101. There are two distinct types of multi-tasking : 
		thread based :
			in thread based multi-tasking, a thread is the smallest unit of code.
			A single program can have multiple tasks running simultaneously.
		process based : 
			basically two processes or programs run concurrently
			In process based multi-tasking, a program is the smallest unit of code that can be dispatched by the scheduler
	
	So process based multi-tasking handles the big picture and thread based multi-tasking handles the details.
	
	102. 
		Switching between processes is costly
		Switching between threads is less costly
		
		Processes are heavy weight
		threads are lighter
		
		Interprocess communication is costly
		InterThread communication is less costly
		
		Processes have different address space
		Threads share same address space.
		
	103. In single core system, threads are given a slice of CPU time, therefore, threads don't run concurrently instead they run when the CPU is in idle state because other thread has paused its execution.
	On other hand multi-core cpus concurrently run threads.
	
	104. Threads exist in several states : 
		running 
		suspended (can be resumed)
		resumed (picks up where it left)
		blocked (waiting for resources)
		terminated (cannote be resumed)
	
	105. java assigns each thread a priority.
	These priorities are integers that are assigned to threads that specify relative priority from one thread to another
	
	106. Java priorities decides when to switch from one running thread to the next. This is called as context switch.
	Rules to determine when context switch takes place are as follows : 
		1. thread voluntarily relinquishes/gives up the control. This can happen when the thread has completed its execution, sleeping or when blocked. In this case the priorities of other threads are checked and the highest priority thread is given CPU.
		2. Thread is preemptied by a higher-priority thread. This happens when a lower priority thread that does not yeild the processor is simply preemptied as soon as a higher priority thread wants to execute.
		THIS IS CALLED AS PREEMPTIVE MULTITASKING.
		
	If there are two threads with same priority, in that case, either the threads are ran in time slice in round robin fashion or the threads must voluntarily yeild control, if they don't then the other threads will not run.
	
	107. Synchronization : 
		To implement synchronization, java has something called as a monitor. 
		Inside a monitor only one thread can run and all the other threads wait for its execution.
		In java all objects have an implicit monitor that is automatically entered when one of the object's synchronized method is called.
		Once inside the synchronized method, no other thread can call any other synchronized method on the same object.
		
	108. Messaging : 
		Java provides a low cost way for two threads to communicate.
		
	109. To create a new thread, we need to either extend the Thread class or implement the Runnable interface.
	
	110. The thread class have following methods that help manage threads : 
		getName() -> return threads name
		getPriority()
		isAlive() -> tells if thread is still running 
		join() -> wait for a thread to terminate 
		run() -> defines the entry point for a thread
		sleep() -> suspends thread for given period of time
		start() -> starts the thread by calling its run method
		
	111. main thread : 
		When java program starts, this thread starts running immediately.
		It does two important things :
			1. all the child threads are spawned from main thread
			2. This thread must be the last thread to finish execution because it performs shutdown actions.
		
	112. how to control main thread : 
		To control main thread, we need to call the currentThread() of the Thread class.
		This is a static method and its form is like : 
			static Thread currentThread()
			
		This returns the reference of the current thread in which it is called.
		
	113. Displaying a thread in println statement : 
		When we print a reference containing a thread, it follows a general format : 
			Thread[threadName, priorityInt, groupName];
		By default main thread has the name as main, priority as 5 and group name as main.
			eg. 
				Thread[main, 5 main]
	
	114. What is a thread group ? 
		a thread group is a data structure that controls the state of a collection of thread as a whole.
		
	115. How to set name of a thread ?
		we can use the setName() of the thread instance to change the internal name of the thread
		
	116. How to suspend execution of a thread ?
		To suspend the execution of a thread we need to use the sleep() method which is of the form : 
			static void sleep(long milsec) throws InterruptedException
		
		eg. : 
			Thread.sleep(5000) -> suspended for 5 sec
			
	117. Creating a thread : 
		We create a thread by instantiating an object of type Thread. There are two ways to accomplish this :
			implement Runnable interface :
				easiest way to create a thread
				Runnable abstracts a unit of executable code
				we need to implement only run()
				Inside the run() we need to define the code that constitutes the new thread. It can contain any variable, class calls object instantiation etc. Whatever that a main thread can do.
				this run() establishes an entry point for concurrent thread execution.
				This new thread will end when run() returns.
				
				Once the class is created with run() method, we need to instantiate the Thread object.
				
				The contructor of the Thread object that we can use to create thread using Runnable is as follows : 
					Thread(Runnable obj, String threadName);
					OR
					Thread(Runnable obj);
					
					obj is the instance of the class that has implemented Runnable interface
					
				After the new Thread is created, it will not start running. 
				We need to call the start() method. This method call will initiate the call to the run() declared in the class implementing runnable.
			extend Thread class : 
				In this our class extends the Thread class.
				We need to override the run() method to define the thread execution steps.
				To create a thread, we can simply create an object of this class.
				To start the execution of the thread we need to call the start() of this object. The start() method is inherited from the Thread class in this case.
			
			The difference between the two methods is that : 
				for runnable we need to create a thread and then send an implementation instance to the constructor and the call the start method of the thread.
				For extending the thread class since we already are extending the thread class we can use the object of the same class and call the start method of the same class.
				
			eg  :
				class Thread1 implements Runnable {
					public void run() {
						System.out.println("inside thread 1");
					}
				}

				class Thread2 extends Thread {
					public void run() {
						System.out.println("inside thread 2");
					}
				}
				
				Thread t1 = new Thread(new Thread1());
				t1.start();
				
				Thread t2 = new Thread2();
				t2.start();
	
	118. when to use runnable and when to use Thread ? 
		one is extended one is inherited 
		many programmers fill that a class should be extended only when they are being enhanced or adapted in some ways. So if we are not overriding any other method apart from run() from the Thread class, then we should probably use Runnable.
		
	119. How to ensure that the main thread is the last one to terminate ?
		We can do this using two methods of the thread class : 
			isAlive() : 
				This method returns true if the thread is still running and returns false otherwise.
			join() :
				This method waits until the thread on which it is called is termintated.
				eg. 
					nt.t1.start();
					nt.t1.join(); -> waits until t1 terminates
		both isAlive and join are final methods therefore cannot be overriden.
		
	120. How to set priority to a thread ?
		use the method setPriority of the Thread class : 
			final void setPriority(int level);
			level should be between MIN_PRIORITY AND MAX_PRIORITY which is having value as 1 and 10 respectively
			
	121. Synchronization : 
		The process to ensure a common resource is being used by only one thread at a time is called as synchronization
		This is done by the monitor object. Only one thread can own a monitor at a time.
	
	122. implementing synchronization : 
		using synchronized methods : 
			we need to add the synchronized keyword before the method definition :
				synchronized void methodName() {}
			
			Remember when a thread enters a synchronized method, no other method can access any synchronized method in the same instance. Non-synchronized methods are callable.
		Usign synchronized statement : 
			But what if we are not writing the class definition and therefore cannot add synchronized keyword to the method ?
				in this case we need to call the method in a synchronized block.
				syntax :
					synchronized(objRef) {
						//statement to be synchronized.
					}
					objRef is the object whose method we want to run in sync env
	123. What is a race condition : 
		the situation in which more than one thread is trying to access and update a common resource.
	
	124. To avoid polling, java includes an elegant interprocess communication mechanism via the wait(), notify() and notifyAll() methods
	All three of these methods can be called from a synchronized context.
	
	wait() :
		This method tells the calling thread to give up the monitor and go to sleep until another thread enters the same monitor and calls the notify() or notifyAll() method.
	notify() : 
		wakes up a thread that called wait() on the same object
	notifyAll() : 
		wakes up all the threads that called wait() on the same object.
	
	125. Deadlock happens when a pair of threads have a circular dependency on a pair of synchronized objects
	
	126. we can obtain the current state of the thread by calling the 
		getState() method.
		it returns a value of type : 
			Thread.State
		
		Thread.State is an enumeration and it has the following values : 
			BlOCKED : suspended because waiting to acquare lock
			NEW : not begun execution
			RUNNABLE : is running or is waiting for access to CPU
			TERMINATED : completed
			TIMED_WAITING : when called sleep() or timed version of join() or timed version of wait()
			WAITING : untimed version of wait() or join()
	
	127. Too many threads also degrade the performance because context switching also takes some processing.
	
	128. A lambda expression is an anonymous/unnamed method
	lambda expressions are not executed on their own.
	They are used to implement a method defined by a functional interface.
	Therefore, a lambda expression results in a form of anonymous class.
	they are also commonly referred to as closures
	
	129. what is a functional interface ?
		It is an interface that contain only one abstract method.
		This method specifies the intended purpose of the interface.
		eg: 
			Runnable interface
	
		Functional interface defines the target type of a lambda expression.
		Meaning, it gets the type of the expression from the context rather than specifying the type explicitly.
		
		NOTE : FUNCTIONAL INTERFACE IS SOMETIMES REFERRED TO AS SAM TYPE. WHERE SAM STANDS FOR SINGLE ABSTRACTION METHOD
		
	130. Implementing lambda expression : 
		we need to implement the lambda using the arrow operator : 
			"->"
		
		The arrow divides the lambda expression in two parts : 
			left side :
				defines the parameters of the lambda expression.
				It is a list of parameters.
				If no parameters then provide an empty list.
				eg. 
					() -> // no parameters
					(a, b) -> // two parameters			
				NOTE : WE CAN MENTION THE TYPE OF THE PARAMETER FOR A LAMBDA FUNCTION BUT IN MANY CASES IT CAN BE INFERRED
				
				If there is only one parameter in the lambda expression, then no need to specify (), we can have something like this : 
					n -> (n%2)==0
				
			right side : 
				it contains the lambda body which specifies the actions of the lambda expression.
				There are two type of bodies :
					single expression 
					eg.
						() -> 123.1 
						This means that this expression is simply returning 123.1
					block of code
					eg.
						() -> {}
						Need explicit return statements
				Lambdas with single statements are called as expression lambda 
				Lambdas with block statements are called as block lambda
		The -> can be verbalized as "becomes" or "goes to"
		
	131. A lambda expression is not executed on its own, rather it forms the implementation of the abstract method defined by the functional interface that specifies its target type.
	
	132. Lambda expression with functional interface : 
		We create a reference variable of the type of functional interface.
		Then we assign the lambda expression to the reference variable.
		
		Now consider we have functional interface of the form : 
			interface MyNumber {
				double getNumber();
			}
		and we have a reference variable as : 
			MyNumber obj;
		
		Now we need to assign lambda expression to this : 
			obj = () -> 1.1;
		
		When this happens an instance of a class is automatically created that implements the functional interface, with the lambda expression defining the behaviour of the abstract method of the interface. When the method is called using the reference variable, the lambda is executed.
		
		This gives us a way to transform a code segment into an object
		
		NOTE : IN ORDER FOR LAMBDA EXPRESSION TO BE USED IN A TARGET TYPE CONTEXT, THE TYPE OF THE ABSTRACT METHOD AND TYPE OF LAMBDA EXPRESSION SHOULD BE COMPATIBLE.
		ALSO THE NUMBER OF PARAMETERS OF THE METHOD AND LAMBDA SHOULD BE COMPATIBLE
		ALSO THE EXCEPTION THROWN SHOULD BE ACCEPTABLE
		
	133. Lambda expressions cannot be generic, however, the functional interface can be generic.
	In this case, the type specified while creating a reference will be used as a target type
	
	134. passing lambda expressions as arguments :
		since lambdas can be used in any context that provides a target type, we can use them as arguments
		For this to work, the parameter type should be of the functional interface type.
		So basically we are sending an instance that is created implicitly as a parameter to the method.
		
	135. If lamda throws a checked exception then in that case, the functional interface should specify the list of that exception in the throws clause
	
	136. A lambda expression can access and use an instance or static variable of the enclosing class.
	Thus, lambda can set the values of instance and static variable and also call method defined by its enclosing class.
	Although, when the local variables from the enclosing scope is used, this is called variable capturing. And they are used in the expression it should be effectively final.
	For example refer : 
		page no. 639
		
	It is important to emphasize that a lambda expression can use and modify an instance variable from its invoking class. It just cant use a local variable of its enclosing scope unless that variable is effectively final.
	
	137. prior to collection framework, java provided ad hoc classes such as dictionary, vector, stack and properties
	
	138. The entire collection framework is built upon a set of standard interfaces. Several implementations of these interfaces are provided that we can use as it is.
	
	139. we can also implement our own collection.
	
	140. Algorithms are another important part of the collections. Algorithms operate on collections and are defined as static methods within the Collections class.
	
	141. Iterator interface is also closely related to the collections. Iterator allows a general-purpose, standardized way of accessing each element of the collection.
	
	142. since each collection provides an iterator, the elements of any collection class can be accessed through the methods defined by Iterator
	
	143. From JDK 8 we have another type of iterator called as spliterator. Spliterator are iterators that provide support for parallel iteration.
	
	144. Although maps are part of the Collections framework, they are not "collections" in the strict use of term
	However we can have a collection view of a map.

	145. The Collections framework defines several core interfaces.
	The interfaces available in the collections framework : 
		Collection : 
			top of collections hierarchy.
			it enables us to work with groups of objects.
		Queue : 
			this interface extends Collection interface to handle special types of lists that follow queue DS, meaning elements can be removed only from head.
		List :
			This interface extends collection to handle sequences(list of objects)
		Set :
			This interface extends collection to implement set, meaning sequence of unique objects.
		SortedSet : 
			This interface extends the set interface to handle sorted sets as the name suggests.
		NavigableSet :
			This interface extends sortedSet interface to handle retrievel of elements based on closest match searches.
		Deque : 
			This interface extends Queue interface to handle doubly ended queues.
			
	146. Comparator interface is used to compare two objects.
	
	147. To provide flexibility the collection interface allows some methods to be optional. The optional methods enables us to modify the contents of the collection. 
	
	Collections that support these methods are called as modifiable.
	Collections that do not support the methods that modify the content of the collection are called as unmodifiable collections.
	
	Collections can only store references and not values of primitive types.
	
	148. Collection Interface : 
		Foundation of collections
		must be implemented by any class that defines the collection.
		generic interface 
			interface Collection<E>
			E -> type of object that the collection will hold
		NOTE : 
			COLLECTION EXTENDS THE ITERABLE INTERFACE, THEREFORE, ALL THE COLLECTIONS CAN BE ITERATED THROUGH THE USE OF FOR-EACH STYLE LOOP.
		
		Collection interface declares the core methods that all collections will have.
		These methods are as follows : 
			boolean add(E obj) -> returns true if object added successfully else false if object cannot be added.
			
			boolean addAll(Collection<? extends E> c) -> adds all the elements of c in the invoking collection.
			
			void clear() -> removes all the elements 
			
			boolean contains(Object obj) -> checks if obj is present in the collection.
			
			boolean containsAll(Collection<?> c) -> returns true if invoking collection contains all the elements from c else false.
			
			boolean equals(Object obj) -> returns true if the obj and invoking collections are equal.
			
			int hashCode() -> returns the hashcode for the collection
			
			boolean isEmpty() 
			boolean remove(Object obj)
			boolean removeAll(Collection<?> c)
			boolean retainAll(Collection <?> c)
			int size()
			Iterator<E> iterator()
			default Spliterator<E> spliterator()
			default Stream<E> stream/parallelStream()
			
	149. List interface : 
		extends Collection interface
		stores a sequence of elements
		elements can be accessed and inserted using the position in the list using zero-based index.
		can contain duplicate elements.
		generic interface :
			interface List<E> 
		Since list is extending the Collection interface it will have those methods in it and it also have some methods of its own. They are as follows : 
			void add(int index, E obj)
			boolean addAll(int index, Collection<? extends E> c)
			static <E> List<E> copyOf(Collection <? extends E> from)
			IMP : E get(int index) -> retrievel method
			IMP : int indexOf(Object obj) -> returns index of first instance if not present returns -1
			int lastIndexOf(Object obj) 
			ListIterator<E> listIterator()
			ListIterator<E> listIterator(int index) -> iterator starting from that index.
			IMP : E remove(int index) -> deletes the element at index and all the subsequent element indexes are decremented by one.
			IMP : E set(int index, E obj) -> assigns the object to the location of index and returns the old value.
			IMP : default void sort(Comparator <? super E> comp) -> sorts using the comparator.
			IMP : List<E> subList<int start, int end) -> sublist from start to end-1
		
	150. set interface : 
		extends the collection interface
		specifies the behaviour of the collection that dont allow duplicate elements.
		does not have additional methods of its own.
		is a generic interface :
			interface Set<E>
	
	151. sortedSet interface : 
		extends the set interface 
		declares the behaviour of a set stored in ascending order.
		is a generic interface :
			interface SortedSet<E>
		Apart from methods from set which are essentially methods from collection SortedSet have some methods of its own. They are : 
			Comparater<? super E> comparator() 
			IMP : E first() -> returns first element
			SortedSet<E> headSet(E end) -> returns a sortedSet of elements that are less than "end" param.
			IMP : E last() -> returns the last element.
			IMP : SortedSet<E> subSet(E start, E end) -> returns subset from start and end-1
			SortedSet<E> tailSet(E start) -> returns all the elements that are greater that start.
			
	152. NavigableSet interface : 
		extends SortedSet interface
		declares the behaviour of a collection that supports the retrieval of elements based on the closest match to a given value or values.
		is generic interface : 
			interface NavigableSet<E>
	153.
	154.
	155.
	156.
	157.
	158.
	159.
	160.
	161.
	162.
	163.
	164.
	165.
	166.
	167.
	168.
	169.
	170.
	171.
	172.
	173.
	174.
	175.
	176.
	177.
	178.
	179.
	180.
	current page : 849 - queue interfaces
	
	topics remaining : JDBC, I/O, try-with-resources(chaptor 13), generics(chaptor 14)
	annotation, enumeration (chapter 12)
	method references (page 641)

